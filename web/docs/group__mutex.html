<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: mutex</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__mutex.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mutex<div class="ingroups"><a class="el" href="group__high__level.html">High Level APIs</a> &raquo; <a class="el" href="group__pico__sync.html">pico_sync</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Mutex API for non IRQ mutual exclusion between cores.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive mutex instance  <a href="structrecursive__mutex__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutex.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">regular (non recursive) mutex instance  <a href="structmutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa1b5d9dea897013fc5e40bf102045592"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">auto_init_mutex</a>(name)&#160;&#160;&#160;static __attribute__((section(&quot;.mutex_array&quot;))) mutex_t name</td></tr>
<tr class="memdesc:gaa1b5d9dea897013fc5e40bf102045592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for static definition of mutexes.  <a href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">More...</a><br /></td></tr>
<tr class="separator:gaa1b5d9dea897013fc5e40bf102045592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c019cd595a52ee87e06bdf20e427660"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">auto_init_recursive_mutex</a>(name)&#160;&#160;&#160;static __attribute__((section(&quot;.mutex_array&quot;))) recursive_mutex_t name = { .core = { .spin_lock = (spin_lock_t *)1 /* marker for <a class="el" href="group__pico__runtime.html#gad27ee86dcd85855022a424f61b839d04">runtime_init</a> */ }, .owner = 0, .enter_count = 0 }</td></tr>
<tr class="memdesc:ga3c019cd595a52ee87e06bdf20e427660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for static definition of recursive mutexes.  <a href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">More...</a><br /></td></tr>
<tr class="separator:ga3c019cd595a52ee87e06bdf20e427660"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac32ff6793a910bc7b48c8b0bb3c47ea7"><td class="memItemLeft" align="right" valign="top"><a id="gac32ff6793a910bc7b48c8b0bb3c47ea7" name="gac32ff6793a910bc7b48c8b0bb3c47ea7"></a>
typedef struct <a class="el" href="structmutex.html">mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mutex_t</b></td></tr>
<tr class="memdesc:gac32ff6793a910bc7b48c8b0bb3c47ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">regular (non recursive) mutex instance <br /></td></tr>
<tr class="separator:gac32ff6793a910bc7b48c8b0bb3c47ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0be65abf0782a68a724bd6d37fd5e010"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga0be65abf0782a68a724bd6d37fd5e010">critical_section_is_initialized</a> (critical_section_t *crit_sec)</td></tr>
<tr class="memdesc:ga0be65abf0782a68a724bd6d37fd5e010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a <a class="el" href="structcritical__section.html">critical_section</a> has been initialized.  <a href="group__mutex.html#ga0be65abf0782a68a724bd6d37fd5e010">More...</a><br /></td></tr>
<tr class="separator:ga0be65abf0782a68a724bd6d37fd5e010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe21d7ce624db2df7afe86c4bba400a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">mutex_init</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:gabe21d7ce624db2df7afe86c4bba400a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a mutex structure.  <a href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">More...</a><br /></td></tr>
<tr class="separator:gabe21d7ce624db2df7afe86c4bba400a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d1f9d58564a1799e293451edc2d28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">recursive_mutex_init</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:ga30d1f9d58564a1799e293451edc2d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a recursive mutex structure.  <a href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">More...</a><br /></td></tr>
<tr class="separator:ga30d1f9d58564a1799e293451edc2d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65b1c7af0545f478c80b51513d8f6993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga65b1c7af0545f478c80b51513d8f6993">mutex_enter_blocking</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:ga65b1c7af0545f478c80b51513d8f6993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of a mutex.  <a href="group__mutex.html#ga65b1c7af0545f478c80b51513d8f6993">More...</a><br /></td></tr>
<tr class="separator:ga65b1c7af0545f478c80b51513d8f6993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11f3d954d96cfdc77025735d35983e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gad11f3d954d96cfdc77025735d35983e1">recursive_mutex_enter_blocking</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:gad11f3d954d96cfdc77025735d35983e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of a recursive mutex.  <a href="group__mutex.html#gad11f3d954d96cfdc77025735d35983e1">More...</a><br /></td></tr>
<tr class="separator:gad11f3d954d96cfdc77025735d35983e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa116de2f28fd7df8fb78b210e07b1ed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">mutex_try_enter</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx, uint32_t *owner_out)</td></tr>
<tr class="memdesc:gaa116de2f28fd7df8fb78b210e07b1ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take ownership of a mutex.  <a href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">More...</a><br /></td></tr>
<tr class="separator:gaa116de2f28fd7df8fb78b210e07b1ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91088e6bd3929dcf86ed12cd92ee2cd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga91088e6bd3929dcf86ed12cd92ee2cd8">mutex_try_enter_block_until</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:ga91088e6bd3929dcf86ed12cd92ee2cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take ownership of a mutex until the specified time.  <a href="group__mutex.html#ga91088e6bd3929dcf86ed12cd92ee2cd8">More...</a><br /></td></tr>
<tr class="separator:ga91088e6bd3929dcf86ed12cd92ee2cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae431bbb90e45cf9ae47130a5635aa2b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gae431bbb90e45cf9ae47130a5635aa2b0">recursive_mutex_try_enter</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx, uint32_t *owner_out)</td></tr>
<tr class="memdesc:gae431bbb90e45cf9ae47130a5635aa2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to take ownership of a recursive mutex.  <a href="group__mutex.html#gae431bbb90e45cf9ae47130a5635aa2b0">More...</a><br /></td></tr>
<tr class="separator:gae431bbb90e45cf9ae47130a5635aa2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c6e468289a81a49b4bde50a6280f83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga32c6e468289a81a49b4bde50a6280f83">mutex_enter_timeout_ms</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga32c6e468289a81a49b4bde50a6280f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex with timeout.  <a href="group__mutex.html#ga32c6e468289a81a49b4bde50a6280f83">More...</a><br /></td></tr>
<tr class="separator:ga32c6e468289a81a49b4bde50a6280f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54a0bdb7967571caecb62869bd4194d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gad54a0bdb7967571caecb62869bd4194d">recursive_mutex_enter_timeout_ms</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:gad54a0bdb7967571caecb62869bd4194d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for recursive mutex with timeout.  <a href="group__mutex.html#gad54a0bdb7967571caecb62869bd4194d">More...</a><br /></td></tr>
<tr class="separator:gad54a0bdb7967571caecb62869bd4194d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553f33e9692a19f8ad956a8b770858e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga553f33e9692a19f8ad956a8b770858e0">mutex_enter_timeout_us</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx, uint32_t timeout_us)</td></tr>
<tr class="memdesc:ga553f33e9692a19f8ad956a8b770858e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex with timeout.  <a href="group__mutex.html#ga553f33e9692a19f8ad956a8b770858e0">More...</a><br /></td></tr>
<tr class="separator:ga553f33e9692a19f8ad956a8b770858e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeb630a7c13ed3adc567e62c8c737401"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaeeb630a7c13ed3adc567e62c8c737401">recursive_mutex_enter_timeout_us</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx, uint32_t timeout_us)</td></tr>
<tr class="memdesc:gaeeb630a7c13ed3adc567e62c8c737401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for recursive mutex with timeout.  <a href="group__mutex.html#gaeeb630a7c13ed3adc567e62c8c737401">More...</a><br /></td></tr>
<tr class="separator:gaeeb630a7c13ed3adc567e62c8c737401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e2f75f0a38378b20c0f2bf9cc7bbe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">mutex_enter_block_until</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:ga69e2f75f0a38378b20c0f2bf9cc7bbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex until a specific time.  <a href="group__mutex.html#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">More...</a><br /></td></tr>
<tr class="separator:ga69e2f75f0a38378b20c0f2bf9cc7bbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce3ca26cbce71a3e29396264e00e253"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga6ce3ca26cbce71a3e29396264e00e253">recursive_mutex_enter_block_until</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:ga6ce3ca26cbce71a3e29396264e00e253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for mutex until a specific time.  <a href="group__mutex.html#ga6ce3ca26cbce71a3e29396264e00e253">More...</a><br /></td></tr>
<tr class="separator:ga6ce3ca26cbce71a3e29396264e00e253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf528c8fbb5f4532758859d18e24e1673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gaf528c8fbb5f4532758859d18e24e1673">mutex_exit</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:gaf528c8fbb5f4532758859d18e24e1673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of a mutex.  <a href="group__mutex.html#gaf528c8fbb5f4532758859d18e24e1673">More...</a><br /></td></tr>
<tr class="separator:gaf528c8fbb5f4532758859d18e24e1673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f75321a04ba731f5875353fbaebc345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga2f75321a04ba731f5875353fbaebc345">recursive_mutex_exit</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:ga2f75321a04ba731f5875353fbaebc345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of a recursive mutex.  <a href="group__mutex.html#ga2f75321a04ba731f5875353fbaebc345">More...</a><br /></td></tr>
<tr class="separator:ga2f75321a04ba731f5875353fbaebc345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b5ca3e872a6823f6580f1388b6585e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#gae4b5ca3e872a6823f6580f1388b6585e">mutex_is_initialized</a> (<a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:gae4b5ca3e872a6823f6580f1388b6585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for mutex initialized state.  <a href="group__mutex.html#gae4b5ca3e872a6823f6580f1388b6585e">More...</a><br /></td></tr>
<tr class="separator:gae4b5ca3e872a6823f6580f1388b6585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e45154e86f0d206665bbce779d112d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mutex.html#ga97e45154e86f0d206665bbce779d112d">recursive_mutex_is_initialized</a> (<a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *mtx)</td></tr>
<tr class="memdesc:ga97e45154e86f0d206665bbce779d112d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for recursive mutex initialized state.  <a href="group__mutex.html#ga97e45154e86f0d206665bbce779d112d">More...</a><br /></td></tr>
<tr class="separator:ga97e45154e86f0d206665bbce779d112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Mutex API for non IRQ mutual exclusion between cores. </p>
<p >Mutexes are application level locks usually used protecting data structures that might be used by multiple threads of execution. Unlike critical sections, the mutex protected code is not necessarily required/expected to complete quickly, as no other system wide locks are held on account of an acquired mutex.</p>
<p >When acquired, the mutex has an owner (see <a class="el" href="group__lock__core.html#gae28f1d974cf1f1b973127500a764245c">lock_get_caller_owner_id</a>) which with the plain SDK is just the acquiring core, but in an RTOS it could be a task, or an IRQ handler context.</p>
<p >Two variants of mutex are provided; <a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> (and associated mutex_ functions) is a regular mutex that cannot be acquired recursively by the same owner (a deadlock will occur if you try). <a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> (and associated recursive_mutex_ functions) is a recursive mutex that can be recursively obtained by the same caller, at the expense of some more overhead when acquiring and releasing.</p>
<p >It is generally a bad idea to call blocking mutex_ or recursive_mutex_ functions from within an IRQ handler. It is valid to call <a class="el" href="group__mutex.html#gaa116de2f28fd7df8fb78b210e07b1ed4">mutex_try_enter</a> or <a class="el" href="group__mutex.html#gae431bbb90e45cf9ae47130a5635aa2b0">recursive_mutex_try_enter</a> from within an IRQ handler, if the operation that would be conducted under lock can be skipped if the mutex is locked (at least by the same owner).</p>
<p >NOTE: For backwards compatibility with version 1.2.0 of the SDK, if the define PICO_MUTEX_ENABLE_SDK120_COMPATIBILITY is set to 1, then the the regular mutex_ functions may also be used for recursive mutexes. This flag will be removed in a future version of the SDK.</p>
<p >See <a class="el" href="critical__section_8h.html">critical_section.h</a> for protecting access between multiple cores AND IRQ handlers </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa1b5d9dea897013fc5e40bf102045592" name="gaa1b5d9dea897013fc5e40bf102045592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b5d9dea897013fc5e40bf102045592">&#9670;&nbsp;</a></span>auto_init_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define auto_init_mutex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;static __attribute__((section(&quot;.mutex_array&quot;))) mutex_t name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for static definition of mutexes. </p>
<p >A mutex defined as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">auto_init_mutex</a>(my_mutex);</div>
<div class="ttc" id="agroup__mutex_html_gaa1b5d9dea897013fc5e40bf102045592"><div class="ttname"><a href="group__mutex.html#gaa1b5d9dea897013fc5e40bf102045592">auto_init_mutex</a></div><div class="ttdeci">#define auto_init_mutex(name)</div><div class="ttdoc">Helper macro for static definition of mutexes.</div><div class="ttdef"><b>Definition:</b> mutex.h:283</div></div>
</div><!-- fragment --><p >Is equivalent to doing</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structmutex.html">mutex_t</a> my_mutex;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_init_function() {</div>
<div class="line">   <a class="code hl_function" href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">mutex_init</a>(&amp;my_mutex);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mutex_html_gabe21d7ce624db2df7afe86c4bba400a2"><div class="ttname"><a href="group__mutex.html#gabe21d7ce624db2df7afe86c4bba400a2">mutex_init</a></div><div class="ttdeci">void mutex_init(mutex_t *mtx)</div><div class="ttdoc">Initialise a mutex structure.</div><div class="ttdef"><b>Definition:</b> mutex.c:43</div></div>
<div class="ttc" id="astructmutex_html"><div class="ttname"><a href="structmutex.html">mutex</a></div><div class="ttdoc">regular (non recursive) mutex instance</div><div class="ttdef"><b>Definition:</b> mutex.h:60</div></div>
</div><!-- fragment --><p >But the initialization of the mutex is performed automatically during runtime initialization </p>

</div>
</div>
<a id="ga3c019cd595a52ee87e06bdf20e427660" name="ga3c019cd595a52ee87e06bdf20e427660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c019cd595a52ee87e06bdf20e427660">&#9670;&nbsp;</a></span>auto_init_recursive_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define auto_init_recursive_mutex</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;static __attribute__((section(&quot;.mutex_array&quot;))) recursive_mutex_t name = { .core = { .spin_lock = (spin_lock_t *)1 /* marker for <a class="el" href="group__pico__runtime.html#gad27ee86dcd85855022a424f61b839d04">runtime_init</a> */ }, .owner = 0, .enter_count = 0 }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for static definition of recursive mutexes. </p>
<p >A recursive mutex defined as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">auto_init_recursive_mutex</a>(my_recursive_mutex);</div>
<div class="ttc" id="agroup__mutex_html_ga3c019cd595a52ee87e06bdf20e427660"><div class="ttname"><a href="group__mutex.html#ga3c019cd595a52ee87e06bdf20e427660">auto_init_recursive_mutex</a></div><div class="ttdeci">#define auto_init_recursive_mutex(name)</div><div class="ttdoc">Helper macro for static definition of recursive mutexes.</div><div class="ttdef"><b>Definition:</b> mutex.h:306</div></div>
</div><!-- fragment --><p >Is equivalent to doing</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structrecursive__mutex__t.html">recursive_mutex_t</a> my_recursive_mutex;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> my_init_function() {</div>
<div class="line">   <a class="code hl_function" href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">recursive_mutex_init</a>(&amp;my_recursive_mutex);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__mutex_html_ga30d1f9d58564a1799e293451edc2d28e"><div class="ttname"><a href="group__mutex.html#ga30d1f9d58564a1799e293451edc2d28e">recursive_mutex_init</a></div><div class="ttdeci">void recursive_mutex_init(recursive_mutex_t *mtx)</div><div class="ttdoc">Initialise a recursive mutex structure.</div><div class="ttdef"><b>Definition:</b> mutex.c:52</div></div>
<div class="ttc" id="astructrecursive__mutex__t_html"><div class="ttname"><a href="structrecursive__mutex__t.html">recursive_mutex_t</a></div><div class="ttdoc">recursive mutex instance</div><div class="ttdef"><b>Definition:</b> mutex.h:47</div></div>
</div><!-- fragment --><p >But the initialization of the mutex is performed automatically during runtime initialization </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0be65abf0782a68a724bd6d37fd5e010" name="ga0be65abf0782a68a724bd6d37fd5e010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be65abf0782a68a724bd6d37fd5e010">&#9670;&nbsp;</a></span>critical_section_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool critical_section_is_initialized </td>
          <td>(</td>
          <td class="paramtype">critical_section_t *&#160;</td>
          <td class="paramname"><em>crit_sec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a <a class="el" href="structcritical__section.html">critical_section</a> has been initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crit_sec</td><td>Pointer to <a class="el" href="structcritical__section.html">critical_section</a> structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the critical section is initialized, false otherwise </dd></dl>

</div>
</div>
<a id="ga69e2f75f0a38378b20c0f2bf9cc7bbe3" name="ga69e2f75f0a38378b20c0f2bf9cc7bbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e2f75f0a38378b20c0f2bf9cc7bbe3">&#9670;&nbsp;</a></span>mutex_enter_block_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutex_enter_block_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex until a specific time. </p>
<p >Wait until the specific time to take ownership of the mutex. If the caller can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">until</td><td>The time after which to return if the caller cannot be granted ownership of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if mutex now owned, false if timeout occurred before ownership could be granted </dd></dl>

</div>
</div>
<a id="ga65b1c7af0545f478c80b51513d8f6993" name="ga65b1c7af0545f478c80b51513d8f6993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65b1c7af0545f478c80b51513d8f6993">&#9670;&nbsp;</a></span>mutex_enter_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_enter_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of a mutex. </p>
<p >This function will block until the caller can be granted ownership of the mutex. On return the caller owns the mutex</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32c6e468289a81a49b4bde50a6280f83" name="ga32c6e468289a81a49b4bde50a6280f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32c6e468289a81a49b4bde50a6280f83">&#9670;&nbsp;</a></span>mutex_enter_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutex_enter_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex with timeout. </p>
<p >Wait for up to the specific time to take ownership of the mutex. If the caller can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if mutex now owned, false if timeout occurred before ownership could be granted </dd></dl>

</div>
</div>
<a id="ga553f33e9692a19f8ad956a8b770858e0" name="ga553f33e9692a19f8ad956a8b770858e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553f33e9692a19f8ad956a8b770858e0">&#9670;&nbsp;</a></span>mutex_enter_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutex_enter_timeout_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex with timeout. </p>
<p >Wait for up to the specific time to take ownership of the mutex. If the caller can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">timeout_us</td><td>The timeout in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if mutex now owned, false if timeout occurred before ownership could be granted </dd></dl>

</div>
</div>
<a id="gaf528c8fbb5f4532758859d18e24e1673" name="gaf528c8fbb5f4532758859d18e24e1673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf528c8fbb5f4532758859d18e24e1673">&#9670;&nbsp;</a></span>mutex_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe21d7ce624db2df7afe86c4bba400a2" name="gabe21d7ce624db2df7afe86c4bba400a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe21d7ce624db2df7afe86c4bba400a2">&#9670;&nbsp;</a></span>mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a mutex structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae4b5ca3e872a6823f6580f1388b6585e" name="gae4b5ca3e872a6823f6580f1388b6585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4b5ca3e872a6823f6580f1388b6585e">&#9670;&nbsp;</a></span>mutex_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mutex_is_initialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for mutex initialized state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mutex is initialized, false otherwise </dd></dl>

</div>
</div>
<a id="gaa116de2f28fd7df8fb78b210e07b1ed4" name="gaa116de2f28fd7df8fb78b210e07b1ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa116de2f28fd7df8fb78b210e07b1ed4">&#9670;&nbsp;</a></span>mutex_try_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutex_try_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>owner_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take ownership of a mutex. </p>
<p >If the mutex wasn't owned, this will claim the mutex for the caller and return true. Otherwise (if the mutex was already owned) this will return false and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">owner_out</td><td>If mutex was already owned, and this pointer is non-zero, it will be filled in with the owner id of the current owner of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if mutex now owned, false otherwise </dd></dl>

</div>
</div>
<a id="ga91088e6bd3929dcf86ed12cd92ee2cd8" name="ga91088e6bd3929dcf86ed12cd92ee2cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91088e6bd3929dcf86ed12cd92ee2cd8">&#9670;&nbsp;</a></span>mutex_try_enter_block_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mutex_try_enter_block_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mutex.html#gac32ff6793a910bc7b48c8b0bb3c47ea7">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take ownership of a mutex until the specified time. </p>
<p >If the mutex wasn't owned, this method will immediately claim the mutex for the caller and return true. If the mutex is owned by the caller, this method will immediately return false, If the mutex is owned by someone else, this method will try to claim it until the specified time, returning true if it succeeds, or false on timeout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">until</td><td>The time after which to return if the caller cannot be granted ownership of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if mutex now owned, false otherwise </dd></dl>

</div>
</div>
<a id="ga6ce3ca26cbce71a3e29396264e00e253" name="ga6ce3ca26cbce71a3e29396264e00e253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce3ca26cbce71a3e29396264e00e253">&#9670;&nbsp;</a></span>recursive_mutex_enter_block_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recursive_mutex_enter_block_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for mutex until a specific time. </p>
<p >Wait until the specific time to take ownership of the mutex. If the caller already has ownership of the mutex or can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
    <tr><td class="paramname">until</td><td>The time after which to return if the caller cannot be granted ownership of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the recursive mutex (now) owned, false if timeout occurred before ownership could be granted </dd></dl>

</div>
</div>
<a id="gad11f3d954d96cfdc77025735d35983e1" name="gad11f3d954d96cfdc77025735d35983e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11f3d954d96cfdc77025735d35983e1">&#9670;&nbsp;</a></span>recursive_mutex_enter_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recursive_mutex_enter_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take ownership of a recursive mutex. </p>
<p >This function will block until the caller can be granted ownership of the mutex. On return the caller owns the mutex</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad54a0bdb7967571caecb62869bd4194d" name="gad54a0bdb7967571caecb62869bd4194d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54a0bdb7967571caecb62869bd4194d">&#9670;&nbsp;</a></span>recursive_mutex_enter_timeout_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recursive_mutex_enter_timeout_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for recursive mutex with timeout. </p>
<p >Wait for up to the specific time to take ownership of the recursive mutex. If the caller already has ownership of the mutex or can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the recursive mutex (now) owned, false if timeout occurred before ownership could be granted </dd></dl>

</div>
</div>
<a id="gaeeb630a7c13ed3adc567e62c8c737401" name="gaeeb630a7c13ed3adc567e62c8c737401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeb630a7c13ed3adc567e62c8c737401">&#9670;&nbsp;</a></span>recursive_mutex_enter_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recursive_mutex_enter_timeout_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for recursive mutex with timeout. </p>
<p >Wait for up to the specific time to take ownership of the recursive mutex. If the caller already has ownership of the mutex or can be granted ownership of the mutex before the timeout expires, then true will be returned and the caller will own the mutex, otherwise false will be returned and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to mutex structure </td></tr>
    <tr><td class="paramname">timeout_us</td><td>The timeout in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the recursive mutex (now) owned, false if timeout occurred before ownership could be granted </dd></dl>

</div>
</div>
<a id="ga2f75321a04ba731f5875353fbaebc345" name="ga2f75321a04ba731f5875353fbaebc345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f75321a04ba731f5875353fbaebc345">&#9670;&nbsp;</a></span>recursive_mutex_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recursive_mutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of a recursive mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d1f9d58564a1799e293451edc2d28e" name="ga30d1f9d58564a1799e293451edc2d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d1f9d58564a1799e293451edc2d28e">&#9670;&nbsp;</a></span>recursive_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recursive_mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a recursive mutex structure. </p>
<p >A recursive mutex may be entered in a nested fashion by the same owner</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97e45154e86f0d206665bbce779d112d" name="ga97e45154e86f0d206665bbce779d112d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97e45154e86f0d206665bbce779d112d">&#9670;&nbsp;</a></span>recursive_mutex_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool recursive_mutex_is_initialized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test for recursive mutex initialized state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the recursive mutex is initialized, false otherwise </dd></dl>

</div>
</div>
<a id="gae431bbb90e45cf9ae47130a5635aa2b0" name="gae431bbb90e45cf9ae47130a5635aa2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae431bbb90e45cf9ae47130a5635aa2b0">&#9670;&nbsp;</a></span>recursive_mutex_try_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool recursive_mutex_try_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrecursive__mutex__t.html">recursive_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>owner_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to take ownership of a recursive mutex. </p>
<p >If the mutex wasn't owned or was owned by the caller, this will claim the mutex and return true. Otherwise (if the mutex was already owned by another owner) this will return false and the caller will NOT own the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx</td><td>Pointer to recursive mutex structure </td></tr>
    <tr><td class="paramname">owner_out</td><td>If mutex was already owned by another owner, and this pointer is non-zero, it will be filled in with the owner id of the current owner of the mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the recursive mutex (now) owned, false otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>