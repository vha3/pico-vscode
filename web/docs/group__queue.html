<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: queue</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__queue.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">queue<div class="ingroups"><a class="el" href="group__high__level.html">High Level APIs</a> &raquo; <a class="el" href="group__pico__util.html">pico_util</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Multi-core and IRQ safe queue implementation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6b379b09df9ac326e3c07a2727b7ca96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga6b379b09df9ac326e3c07a2727b7ca96">queue_init_with_spinlock</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, uint element_size, uint element_count, uint spinlock_num)</td></tr>
<tr class="memdesc:ga6b379b09df9ac326e3c07a2727b7ca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a queue with a specific spinlock for concurrency protection.  <a href="group__queue.html#ga6b379b09df9ac326e3c07a2727b7ca96">More...</a><br /></td></tr>
<tr class="separator:ga6b379b09df9ac326e3c07a2727b7ca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa8e36b5c51158d836e16c5be2b9925"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga0aa8e36b5c51158d836e16c5be2b9925">queue_init</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, uint element_size, uint element_count)</td></tr>
<tr class="memdesc:ga0aa8e36b5c51158d836e16c5be2b9925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a queue, allocating a (possibly shared) spinlock.  <a href="group__queue.html#ga0aa8e36b5c51158d836e16c5be2b9925">More...</a><br /></td></tr>
<tr class="separator:ga0aa8e36b5c51158d836e16c5be2b9925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13034dd0decdb0faf1b863383560be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#gaa13034dd0decdb0faf1b863383560be2">queue_free</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q)</td></tr>
<tr class="memdesc:gaa13034dd0decdb0faf1b863383560be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the specified queue.  <a href="group__queue.html#gaa13034dd0decdb0faf1b863383560be2">More...</a><br /></td></tr>
<tr class="separator:gaa13034dd0decdb0faf1b863383560be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ebf4d2dec7ad019b03c2994defdf046"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga2ebf4d2dec7ad019b03c2994defdf046">queue_get_level_unsafe</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q)</td></tr>
<tr class="memdesc:ga2ebf4d2dec7ad019b03c2994defdf046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsafe check of level of the specified queue.  <a href="group__queue.html#ga2ebf4d2dec7ad019b03c2994defdf046">More...</a><br /></td></tr>
<tr class="separator:ga2ebf4d2dec7ad019b03c2994defdf046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc5a58d2cac83f33aac5e8bb4e35147"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga5cc5a58d2cac83f33aac5e8bb4e35147">queue_get_level</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q)</td></tr>
<tr class="memdesc:ga5cc5a58d2cac83f33aac5e8bb4e35147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check of level of the specified queue.  <a href="group__queue.html#ga5cc5a58d2cac83f33aac5e8bb4e35147">More...</a><br /></td></tr>
<tr class="separator:ga5cc5a58d2cac83f33aac5e8bb4e35147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8456f240608d3e58e5323bedadaeebe2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga8456f240608d3e58e5323bedadaeebe2">queue_is_empty</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q)</td></tr>
<tr class="memdesc:ga8456f240608d3e58e5323bedadaeebe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if queue is empty.  <a href="group__queue.html#ga8456f240608d3e58e5323bedadaeebe2">More...</a><br /></td></tr>
<tr class="separator:ga8456f240608d3e58e5323bedadaeebe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8287f549f6065fc89c5b56b9f9212e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#gaed8287f549f6065fc89c5b56b9f9212e">queue_is_full</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q)</td></tr>
<tr class="memdesc:gaed8287f549f6065fc89c5b56b9f9212e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if queue is full.  <a href="group__queue.html#gaed8287f549f6065fc89c5b56b9f9212e">More...</a><br /></td></tr>
<tr class="separator:gaed8287f549f6065fc89c5b56b9f9212e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ddfda77fa6e9c6292deda62d993ae3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga42ddfda77fa6e9c6292deda62d993ae3">queue_try_add</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, const void *data)</td></tr>
<tr class="memdesc:ga42ddfda77fa6e9c6292deda62d993ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking add value queue if not full.  <a href="group__queue.html#ga42ddfda77fa6e9c6292deda62d993ae3">More...</a><br /></td></tr>
<tr class="separator:ga42ddfda77fa6e9c6292deda62d993ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31806423ac9c0b39ee7bb6473aa8d253"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga31806423ac9c0b39ee7bb6473aa8d253">queue_try_remove</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, void *data)</td></tr>
<tr class="memdesc:ga31806423ac9c0b39ee7bb6473aa8d253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking removal of entry from the queue if non empty.  <a href="group__queue.html#ga31806423ac9c0b39ee7bb6473aa8d253">More...</a><br /></td></tr>
<tr class="separator:ga31806423ac9c0b39ee7bb6473aa8d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d65c218a1826243d64f6305417dcc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#gab2d65c218a1826243d64f6305417dcc0">queue_try_peek</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, void *data)</td></tr>
<tr class="memdesc:gab2d65c218a1826243d64f6305417dcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking peek at the next item to be removed from the queue.  <a href="group__queue.html#gab2d65c218a1826243d64f6305417dcc0">More...</a><br /></td></tr>
<tr class="separator:gab2d65c218a1826243d64f6305417dcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01f5e5ddf3403416097f31acc2dbeca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#gad01f5e5ddf3403416097f31acc2dbeca">queue_add_blocking</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, const void *data)</td></tr>
<tr class="memdesc:gad01f5e5ddf3403416097f31acc2dbeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking add of value to queue.  <a href="group__queue.html#gad01f5e5ddf3403416097f31acc2dbeca">More...</a><br /></td></tr>
<tr class="separator:gad01f5e5ddf3403416097f31acc2dbeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97fb187c127e26935b37785692d1776b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga97fb187c127e26935b37785692d1776b">queue_remove_blocking</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, void *data)</td></tr>
<tr class="memdesc:ga97fb187c127e26935b37785692d1776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remove entry from queue.  <a href="group__queue.html#ga97fb187c127e26935b37785692d1776b">More...</a><br /></td></tr>
<tr class="separator:ga97fb187c127e26935b37785692d1776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104ec5baa82c9635163a511df7abf124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__queue.html#ga104ec5baa82c9635163a511df7abf124">queue_peek_blocking</a> (<a class="el" href="structqueue__t.html">queue_t</a> *q, void *data)</td></tr>
<tr class="memdesc:ga104ec5baa82c9635163a511df7abf124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking peek at next value to be removed from queue.  <a href="group__queue.html#ga104ec5baa82c9635163a511df7abf124">More...</a><br /></td></tr>
<tr class="separator:ga104ec5baa82c9635163a511df7abf124"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Multi-core and IRQ safe queue implementation. </p>
<p >Note that this queue stores values of a specified size, and pushed values are copied into the queue </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad01f5e5ddf3403416097f31acc2dbeca" name="gad01f5e5ddf3403416097f31acc2dbeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01f5e5ddf3403416097f31acc2dbeca">&#9670;&nbsp;</a></span>queue_add_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_add_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking add of value to queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to value to be copied into the queue</td></tr>
  </table>
  </dd>
</dl>
<p>If the queue is full this function will block, until a removal happens on the queue </p>

</div>
</div>
<a id="gaa13034dd0decdb0faf1b863383560be2" name="gaa13034dd0decdb0faf1b863383560be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa13034dd0decdb0faf1b863383560be2">&#9670;&nbsp;</a></span>queue_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle</td></tr>
  </table>
  </dd>
</dl>
<p>Does not deallocate the <a class="el" href="structqueue__t.html">queue_t</a> structure itself. </p>

</div>
</div>
<a id="ga5cc5a58d2cac83f33aac5e8bb4e35147" name="ga5cc5a58d2cac83f33aac5e8bb4e35147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc5a58d2cac83f33aac5e8bb4e35147">&#9670;&nbsp;</a></span>queue_get_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint queue_get_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check of level of the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of entries in the queue </dd></dl>

</div>
</div>
<a id="ga2ebf4d2dec7ad019b03c2994defdf046" name="ga2ebf4d2dec7ad019b03c2994defdf046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ebf4d2dec7ad019b03c2994defdf046">&#9670;&nbsp;</a></span>queue_get_level_unsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint queue_get_level_unsafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unsafe check of level of the specified queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of entries in the queue</dd></dl>
<p>This does not use the spinlock, so may return incorrect results if the spin lock is not externally locked </p>

</div>
</div>
<a id="ga0aa8e36b5c51158d836e16c5be2b9925" name="ga0aa8e36b5c51158d836e16c5be2b9925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa8e36b5c51158d836e16c5be2b9925">&#9670;&nbsp;</a></span>queue_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void queue_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>element_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a queue, allocating a (possibly shared) spinlock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">element_size</td><td>Size of each value in the queue </td></tr>
    <tr><td class="paramname">element_count</td><td>Maximum number of entries in the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b379b09df9ac326e3c07a2727b7ca96" name="ga6b379b09df9ac326e3c07a2727b7ca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b379b09df9ac326e3c07a2727b7ca96">&#9670;&nbsp;</a></span>queue_init_with_spinlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_init_with_spinlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>element_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>element_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>spinlock_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a queue with a specific spinlock for concurrency protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">element_size</td><td>Size of each value in the queue </td></tr>
    <tr><td class="paramname">element_count</td><td>Maximum number of entries in the queue </td></tr>
    <tr><td class="paramname">spinlock_num</td><td>The spin ID used to protect the queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8456f240608d3e58e5323bedadaeebe2" name="ga8456f240608d3e58e5323bedadaeebe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8456f240608d3e58e5323bedadaeebe2">&#9670;&nbsp;</a></span>queue_is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool queue_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if queue is empty, false otherwise</dd></dl>
<p>This function is interrupt and multicore safe. </p>

</div>
</div>
<a id="gaed8287f549f6065fc89c5b56b9f9212e" name="gaed8287f549f6065fc89c5b56b9f9212e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed8287f549f6065fc89c5b56b9f9212e">&#9670;&nbsp;</a></span>queue_is_full()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool queue_is_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if queue is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if queue is full, false otherwise</dd></dl>
<p>This function is interrupt and multicore safe. </p>

</div>
</div>
<a id="ga104ec5baa82c9635163a511df7abf124" name="ga104ec5baa82c9635163a511df7abf124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga104ec5baa82c9635163a511df7abf124">&#9670;&nbsp;</a></span>queue_peek_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_peek_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking peek at next value to be removed from queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the location to receive the peeked value, or NULL if the data isn't required</td></tr>
  </table>
  </dd>
</dl>
<p>If the queue is empty function will block until a value is added </p>

</div>
</div>
<a id="ga97fb187c127e26935b37785692d1776b" name="ga97fb187c127e26935b37785692d1776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97fb187c127e26935b37785692d1776b">&#9670;&nbsp;</a></span>queue_remove_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queue_remove_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking remove entry from queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the location to receive the removed value, or NULL if the data isn't required</td></tr>
  </table>
  </dd>
</dl>
<p>If the queue is empty this function will block until a value is added. </p>

</div>
</div>
<a id="ga42ddfda77fa6e9c6292deda62d993ae3" name="ga42ddfda77fa6e9c6292deda62d993ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ddfda77fa6e9c6292deda62d993ae3">&#9670;&nbsp;</a></span>queue_try_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_try_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking add value queue if not full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to value to be copied into the queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value was added</dd></dl>
<p>If the queue is full this function will return immediately with false, otherwise the data is copied into a new value added to the queue, and this function will return true. </p>

</div>
</div>
<a id="gab2d65c218a1826243d64f6305417dcc0" name="gab2d65c218a1826243d64f6305417dcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2d65c218a1826243d64f6305417dcc0">&#9670;&nbsp;</a></span>queue_try_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_try_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking peek at the next item to be removed from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the location to receive the peeked value, or NULL if the data isn't required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there was a value to peek</dd></dl>
<p>If the queue is not empty this function will return immediately with true with the peeked entry copied into the location specified by the data parameter, otherwise the function will return false. </p>

</div>
</div>
<a id="ga31806423ac9c0b39ee7bb6473aa8d253" name="ga31806423ac9c0b39ee7bb6473aa8d253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31806423ac9c0b39ee7bb6473aa8d253">&#9670;&nbsp;</a></span>queue_try_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool queue_try_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structqueue__t.html">queue_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking removal of entry from the queue if non empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to a <a class="el" href="structqueue__t.html">queue_t</a> structure, used as a handle </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the location to receive the removed value, or NULL if the data isn't required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a value was removed</dd></dl>
<p>If the queue is not empty function will copy the removed value into the location provided and return immediately with true, otherwise the function will return immediately with false. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>