<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: hardware_i2c</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__hardware__i2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hardware_i2c<div class="ingroups"><a class="el" href="group__hardware.html">Hardware APIs</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>I2C Controller API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga15780f5c76a6e85e6a9d91dc6ca754bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga15780f5c76a6e85e6a9d91dc6ca754bc">I2C_NUM</a>(i2c)</td></tr>
<tr class="memdesc:ga15780f5c76a6e85e6a9d91dc6ca754bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the I2C number for a I2C instance.  <a href="group__hardware__i2c.html#ga15780f5c76a6e85e6a9d91dc6ca754bc">More...</a><br /></td></tr>
<tr class="separator:ga15780f5c76a6e85e6a9d91dc6ca754bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa18845e47b403a6a54008a776f56b46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gaaa18845e47b403a6a54008a776f56b46">I2C_INSTANCE</a>(num)</td></tr>
<tr class="memdesc:gaaa18845e47b403a6a54008a776f56b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the I2C instance with the given I2C number.  <a href="group__hardware__i2c.html#gaaa18845e47b403a6a54008a776f56b46">More...</a><br /></td></tr>
<tr class="separator:gaaa18845e47b403a6a54008a776f56b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e96753676145c21b2165f6fde8e0f2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga6e96753676145c21b2165f6fde8e0f2a">I2C_DREQ_NUM</a>(i2c,  is_tx)</td></tr>
<tr class="memdesc:ga6e96753676145c21b2165f6fde8e0f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="group__hardware__dma.html#ga8def0ea481095c94f3a0dd0b4fed999e">dreq_num_t</a> used for pacing DMA transfers to or from this I2C instance. If is_tx is true, then it is for transfers to the I2C instance else for transfers from the I2C instance.  <a href="group__hardware__i2c.html#ga6e96753676145c21b2165f6fde8e0f2a">More...</a><br /></td></tr>
<tr class="separator:ga6e96753676145c21b2165f6fde8e0f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad31793849a130033e94fa5b8e98a30a8"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gad31793849a130033e94fa5b8e98a30a8">i2c_init</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint baudrate)</td></tr>
<tr class="memdesc:gad31793849a130033e94fa5b8e98a30a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the I2C HW block.  <a href="group__hardware__i2c.html#gad31793849a130033e94fa5b8e98a30a8">More...</a><br /></td></tr>
<tr class="separator:gad31793849a130033e94fa5b8e98a30a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e2ac8f345157b0095fc463ac3e584ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga2e2ac8f345157b0095fc463ac3e584ba">i2c_deinit</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c)</td></tr>
<tr class="memdesc:ga2e2ac8f345157b0095fc463ac3e584ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the I2C HW block.  <a href="group__hardware__i2c.html#ga2e2ac8f345157b0095fc463ac3e584ba">More...</a><br /></td></tr>
<tr class="separator:ga2e2ac8f345157b0095fc463ac3e584ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615525cad9398b3ec37e8208523c73b4"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga615525cad9398b3ec37e8208523c73b4">i2c_set_baudrate</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint baudrate)</td></tr>
<tr class="memdesc:ga615525cad9398b3ec37e8208523c73b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C baudrate.  <a href="group__hardware__i2c.html#ga615525cad9398b3ec37e8208523c73b4">More...</a><br /></td></tr>
<tr class="separator:ga615525cad9398b3ec37e8208523c73b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42571b2db5d1ed0dc083385c230dc9e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga42571b2db5d1ed0dc083385c230dc9e8">i2c_set_slave_mode</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, bool slave, uint8_t addr)</td></tr>
<tr class="memdesc:ga42571b2db5d1ed0dc083385c230dc9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C port to slave mode.  <a href="group__hardware__i2c.html#ga42571b2db5d1ed0dc083385c230dc9e8">More...</a><br /></td></tr>
<tr class="separator:ga42571b2db5d1ed0dc083385c230dc9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae747755a45e2fbf96d60bfbc7837f5d"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gaae747755a45e2fbf96d60bfbc7837f5d">i2c_get_index</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c)</td></tr>
<tr class="memdesc:gaae747755a45e2fbf96d60bfbc7837f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert I2C instance to hardware instance number.  <a href="group__hardware__i2c.html#gaae747755a45e2fbf96d60bfbc7837f5d">More...</a><br /></td></tr>
<tr class="separator:gaae747755a45e2fbf96d60bfbc7837f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb868326e8b0bef077a98e1302b0ff9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi2c__hw__t.html">i2c_hw_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gafb868326e8b0bef077a98e1302b0ff9a">i2c_get_hw</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c)</td></tr>
<tr class="memdesc:gafb868326e8b0bef077a98e1302b0ff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointer to structure containing i2c hardware registers.  <a href="group__hardware__i2c.html#gafb868326e8b0bef077a98e1302b0ff9a">More...</a><br /></td></tr>
<tr class="separator:gafb868326e8b0bef077a98e1302b0ff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a132ff74d7b816a6238037fa0e0c2c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga2a132ff74d7b816a6238037fa0e0c2c4">i2c_get_instance</a> (uint num)</td></tr>
<tr class="memdesc:ga2a132ff74d7b816a6238037fa0e0c2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert I2C hardware instance number to I2C instance.  <a href="group__hardware__i2c.html#ga2a132ff74d7b816a6238037fa0e0c2c4">More...</a><br /></td></tr>
<tr class="separator:ga2a132ff74d7b816a6238037fa0e0c2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbad5cc392c9c22618ff9fe3b0f20ea5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gafbad5cc392c9c22618ff9fe3b0f20ea5">i2c_write_blocking_until</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:gafbad5cc392c9c22618ff9fe3b0f20ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write specified number of bytes to address, blocking until the specified absolute time is reached.  <a href="group__hardware__i2c.html#gafbad5cc392c9c22618ff9fe3b0f20ea5">More...</a><br /></td></tr>
<tr class="separator:gafbad5cc392c9c22618ff9fe3b0f20ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga186c30fab0a661586493c8d51a493850"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga186c30fab0a661586493c8d51a493850">i2c_read_blocking_until</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:ga186c30fab0a661586493c8d51a493850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read specified number of bytes from address, blocking until the specified absolute time is reached.  <a href="group__hardware__i2c.html#ga186c30fab0a661586493c8d51a493850">More...</a><br /></td></tr>
<tr class="separator:ga186c30fab0a661586493c8d51a493850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abb49ca0282530c2655f188b72eb653"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga0abb49ca0282530c2655f188b72eb653">i2c_write_timeout_us</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop, uint timeout_us)</td></tr>
<tr class="memdesc:ga0abb49ca0282530c2655f188b72eb653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write specified number of bytes to address, with timeout.  <a href="group__hardware__i2c.html#ga0abb49ca0282530c2655f188b72eb653">More...</a><br /></td></tr>
<tr class="separator:ga0abb49ca0282530c2655f188b72eb653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9662f16f2e0def852f8fc051e695528d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga9662f16f2e0def852f8fc051e695528d">i2c_read_timeout_us</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop, uint timeout_us)</td></tr>
<tr class="memdesc:ga9662f16f2e0def852f8fc051e695528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read specified number of bytes from address, with timeout.  <a href="group__hardware__i2c.html#ga9662f16f2e0def852f8fc051e695528d">More...</a><br /></td></tr>
<tr class="separator:ga9662f16f2e0def852f8fc051e695528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5149e9af84926fa19db6677691ab2900"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga5149e9af84926fa19db6677691ab2900">i2c_write_blocking</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop)</td></tr>
<tr class="memdesc:ga5149e9af84926fa19db6677691ab2900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write specified number of bytes to address, blocking.  <a href="group__hardware__i2c.html#ga5149e9af84926fa19db6677691ab2900">More...</a><br /></td></tr>
<tr class="separator:ga5149e9af84926fa19db6677691ab2900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550d01d4619f702db34355b9e570b1b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga550d01d4619f702db34355b9e570b1b1">i2c_write_burst_blocking</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, const uint8_t *src, size_t len)</td></tr>
<tr class="memdesc:ga550d01d4619f702db34355b9e570b1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to write specified number of bytes to address, blocking in burst mode.  <a href="group__hardware__i2c.html#ga550d01d4619f702db34355b9e570b1b1">More...</a><br /></td></tr>
<tr class="separator:ga550d01d4619f702db34355b9e570b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba4ea440285edec58eba507308c568c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gaba4ea440285edec58eba507308c568c6">i2c_read_blocking</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop)</td></tr>
<tr class="memdesc:gaba4ea440285edec58eba507308c568c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read specified number of bytes from address, blocking.  <a href="group__hardware__i2c.html#gaba4ea440285edec58eba507308c568c6">More...</a><br /></td></tr>
<tr class="separator:gaba4ea440285edec58eba507308c568c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb20f515799c0a68ed597eed1ad9828a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gafb20f515799c0a68ed597eed1ad9828a">i2c_read_burst_blocking</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t addr, uint8_t *dst, size_t len)</td></tr>
<tr class="memdesc:gafb20f515799c0a68ed597eed1ad9828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read specified number of bytes from address, blocking in burst mode.  <a href="group__hardware__i2c.html#gafb20f515799c0a68ed597eed1ad9828a">More...</a><br /></td></tr>
<tr class="separator:gafb20f515799c0a68ed597eed1ad9828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f40022189e591521dd0ae5e29708ff"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga93f40022189e591521dd0ae5e29708ff">i2c_get_write_available</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c)</td></tr>
<tr class="memdesc:ga93f40022189e591521dd0ae5e29708ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine non-blocking write space available.  <a href="group__hardware__i2c.html#ga93f40022189e591521dd0ae5e29708ff">More...</a><br /></td></tr>
<tr class="separator:ga93f40022189e591521dd0ae5e29708ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df361f77f110bbc2b63baa999507bde"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga5df361f77f110bbc2b63baa999507bde">i2c_get_read_available</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c)</td></tr>
<tr class="memdesc:ga5df361f77f110bbc2b63baa999507bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine number of bytes received.  <a href="group__hardware__i2c.html#ga5df361f77f110bbc2b63baa999507bde">More...</a><br /></td></tr>
<tr class="separator:ga5df361f77f110bbc2b63baa999507bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33250d48e1ad099b1ade910fa97e38d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gaf33250d48e1ad099b1ade910fa97e38d">i2c_write_raw_blocking</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, const uint8_t *src, size_t len)</td></tr>
<tr class="memdesc:gaf33250d48e1ad099b1ade910fa97e38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write direct to TX FIFO.  <a href="group__hardware__i2c.html#gaf33250d48e1ad099b1ade910fa97e38d">More...</a><br /></td></tr>
<tr class="separator:gaf33250d48e1ad099b1ade910fa97e38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb6879852dedc00403f8c345e6d64611"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gacb6879852dedc00403f8c345e6d64611">i2c_read_raw_blocking</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t *dst, size_t len)</td></tr>
<tr class="memdesc:gacb6879852dedc00403f8c345e6d64611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read direct from RX FIFO.  <a href="group__hardware__i2c.html#gacb6879852dedc00403f8c345e6d64611">More...</a><br /></td></tr>
<tr class="separator:gacb6879852dedc00403f8c345e6d64611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37f59a13576235e8bed4fffc4bc4361"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gab37f59a13576235e8bed4fffc4bc4361">i2c_read_byte_raw</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c)</td></tr>
<tr class="memdesc:gab37f59a13576235e8bed4fffc4bc4361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a byte from I2C Rx FIFO.  <a href="group__hardware__i2c.html#gab37f59a13576235e8bed4fffc4bc4361">More...</a><br /></td></tr>
<tr class="separator:gab37f59a13576235e8bed4fffc4bc4361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966547dafbfd2bcb2016c132f26767f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga966547dafbfd2bcb2016c132f26767f8">i2c_write_byte_raw</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, uint8_t value)</td></tr>
<tr class="memdesc:ga966547dafbfd2bcb2016c132f26767f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a byte into I2C Tx FIFO.  <a href="group__hardware__i2c.html#ga966547dafbfd2bcb2016c132f26767f8">More...</a><br /></td></tr>
<tr class="separator:ga966547dafbfd2bcb2016c132f26767f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacce469d1b8f8dc9548d1932c5838d9d9"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#gacce469d1b8f8dc9548d1932c5838d9d9">i2c_get_dreq</a> (<a class="el" href="structi2c__inst.html">i2c_inst_t</a> *i2c, bool is_tx)</td></tr>
<tr class="memdesc:gacce469d1b8f8dc9548d1932c5838d9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the DREQ to use for pacing transfers to/from a particular I2C instance.  <a href="group__hardware__i2c.html#gacce469d1b8f8dc9548d1932c5838d9d9">More...</a><br /></td></tr>
<tr class="separator:gacce469d1b8f8dc9548d1932c5838d9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c7844696c095a3ad088100df011fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structi2c__inst.html">i2c_inst_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__i2c.html#ga56c7844696c095a3ad088100df011fd2">i2c0_inst</a></td></tr>
<tr class="separator:ga56c7844696c095a3ad088100df011fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >I2C Controller API. </p>
<p >The I2C bus is a two-wire serial interface, consisting of a serial data line SDA and a serial clock SCL. These wires carry information between the devices connected to the bus. Each device is recognized by a unique 7-bit address and can operate as either a “transmitter” or “receiver”, depending on the function of the device. Devices can also be considered as masters or slaves when performing data transfers. A master is a device that initiates a data transfer on the bus and generates the clock signals to permit that transfer. The first byte in the data transfer always contains the 7-bit address and a read/write bit in the LSB position. This API takes care of toggling the read/write bit. After this, any device addressed is considered a slave.</p>
<p >This API allows the controller to be set up as a master or a slave using the <a class="el" href="group__hardware__i2c.html#ga42571b2db5d1ed0dc083385c230dc9e8">i2c_set_slave_mode</a> function.</p>
<p >The external pins of each controller are connected to GPIO pins as defined in the GPIO muxing table in the datasheet. The muxing options give some IO flexibility, but each controller external pin should be connected to only one GPIO.</p>
<p >Note that the controller does NOT support High speed mode or Ultra-fast speed mode, the fastest operation being fast mode plus at up to 1000Kb/s.</p>
<p >See the datasheet for more information on the I2C controller and its usage.</p>
<h2><a class="anchor" id="i2c_example"></a>
Example</h2>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// Sweep through all 7-bit I2C addresses, to see if any slaves are present on</span></div>
<div class="line"><span class="comment">// the I2C bus. Print out a table that looks like this:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// I2C Bus Scan</span></div>
<div class="line"><span class="comment">//    0 1 2 3 4 5 6 7 8 9 A B C D E F</span></div>
<div class="line"><span class="comment">// 00 . . . . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 10 . . @ . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 20 . . . . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 30 . . . . @ . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 40 . . . . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 50 . . . . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 60 . . . . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// 70 . . . . . . . . . . . . . . . .</span></div>
<div class="line"><span class="comment">// E.g. if addresses 0x12 and 0x34 were acknowledged.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="stdlib_8h.html">pico/stdlib.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="binary__info_8h.html">pico/binary_info.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html">hardware/i2c.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// I2C reserves some addresses for special purposes. We exclude these from the scan.</span></div>
<div class="line"><span class="comment">// These are any addresses of the form 000 0xxx or 111 1xxx</span></div>
<div class="line"><span class="keywordtype">bool</span> reserved_addr(uint8_t addr) {</div>
<div class="line">    <span class="keywordflow">return</span> (addr &amp; 0x78) == 0 || (addr &amp; 0x78) == 0x78;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Enable UART so we can print status output</span></div>
<div class="line">    <a class="code hl_function" href="group__pico__stdio.html#ga0e604311fb226dae91ff4eb17a19d67a">stdio_init_all</a>();</div>
<div class="line"><span class="preprocessor">#if !defined(i2c_default) || !defined(PICO_DEFAULT_I2C_SDA_PIN) || !defined(PICO_DEFAULT_I2C_SCL_PIN)</span></div>
<div class="line"><span class="preprocessor">#warning i2c/bus_scan example requires a board with I2C pins</span></div>
<div class="line">    puts(<span class="stringliteral">&quot;Default I2C pins were not defined&quot;</span>);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    <span class="comment">// This example will use I2C0 on the default SDA and SCL pins (GP4, GP5 on a Pico)</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__i2c.html#gad31793849a130033e94fa5b8e98a30a8">i2c_init</a>(i2c_default, 100 * 1000);</div>
<div class="line">    <a class="code hl_function" href="group__hardware__gpio.html#ga22f6b90c4c7e0013b4b5341de0a44fc4">gpio_set_function</a>(PICO_DEFAULT_I2C_SDA_PIN, <a class="code hl_enumvalue" href="group__hardware__gpio.html#ggaf91b38a4d4e96c343bd16927c34936e0af5897687741f0ee34c88fd9823f1450a">GPIO_FUNC_I2C</a>);</div>
<div class="line">    <a class="code hl_function" href="group__hardware__gpio.html#ga22f6b90c4c7e0013b4b5341de0a44fc4">gpio_set_function</a>(PICO_DEFAULT_I2C_SCL_PIN, <a class="code hl_enumvalue" href="group__hardware__gpio.html#ggaf91b38a4d4e96c343bd16927c34936e0af5897687741f0ee34c88fd9823f1450a">GPIO_FUNC_I2C</a>);</div>
<div class="line">    <a class="code hl_function" href="group__hardware__gpio.html#ga30a6733240f3d2e25e6b579b6c3902da">gpio_pull_up</a>(PICO_DEFAULT_I2C_SDA_PIN);</div>
<div class="line">    <a class="code hl_function" href="group__hardware__gpio.html#ga30a6733240f3d2e25e6b579b6c3902da">gpio_pull_up</a>(PICO_DEFAULT_I2C_SCL_PIN);</div>
<div class="line">    <span class="comment">// Make the I2C pins available to picotool</span></div>
<div class="line">    <a class="code hl_define" href="group__pico__binary__info.html#ga758f119659f2491c89e8e2955d647e9a">bi_decl</a>(bi_2pins_with_func(PICO_DEFAULT_I2C_SDA_PIN, PICO_DEFAULT_I2C_SCL_PIN, <a class="code hl_enumvalue" href="group__hardware__gpio.html#ggaf91b38a4d4e96c343bd16927c34936e0af5897687741f0ee34c88fd9823f1450a">GPIO_FUNC_I2C</a>));</div>
<div class="line"> </div>
<div class="line">    printf(<span class="stringliteral">&quot;\nI2C Bus Scan\n&quot;</span>);</div>
<div class="line">    printf(<span class="stringliteral">&quot;   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> addr = 0; addr &lt; (1 &lt;&lt; 7); ++addr) {</div>
<div class="line">        <span class="keywordflow">if</span> (addr % 16 == 0) {</div>
<div class="line">            printf(<span class="stringliteral">&quot;%02x &quot;</span>, addr);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Perform a 1-byte dummy read from the probe address. If a slave</span></div>
<div class="line">        <span class="comment">// acknowledges this address, the function returns the number of bytes</span></div>
<div class="line">        <span class="comment">// transferred. If the address byte is ignored, the function returns</span></div>
<div class="line">        <span class="comment">// -1.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Skip over any reserved addresses.</span></div>
<div class="line">        <span class="keywordtype">int</span> ret;</div>
<div class="line">        uint8_t rxdata;</div>
<div class="line">        <span class="keywordflow">if</span> (reserved_addr(addr))</div>
<div class="line">            ret = <a class="code hl_enumvalue" href="group__pico__base.html#ggaddcb20bc9a61ceff479aa87369a862aaa3881c25df2261efbc82252df515240d0">PICO_ERROR_GENERIC</a>;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            ret = <a class="code hl_function" href="group__hardware__i2c.html#gaba4ea440285edec58eba507308c568c6">i2c_read_blocking</a>(i2c_default, addr, &amp;rxdata, 1, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">        printf(ret &lt; 0 ? <span class="stringliteral">&quot;.&quot;</span> : <span class="stringliteral">&quot;@&quot;</span>);</div>
<div class="line">        printf(addr % 16 == 15 ? <span class="stringliteral">&quot;\n&quot;</span> : <span class="stringliteral">&quot;  &quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    printf(<span class="stringliteral">&quot;Done.\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
<div class="ttc" id="abinary__info_8h_html"><div class="ttname"><a href="binary__info_8h.html">binary_info.h</a></div></div>
<div class="ttc" id="agroup__hardware__gpio_html_ga22f6b90c4c7e0013b4b5341de0a44fc4"><div class="ttname"><a href="group__hardware__gpio.html#ga22f6b90c4c7e0013b4b5341de0a44fc4">gpio_set_function</a></div><div class="ttdeci">void gpio_set_function(uint gpio, gpio_function_t fn)</div><div class="ttdoc">Select GPIO function.</div><div class="ttdef"><b>Definition:</b> gpio.c:38</div></div>
<div class="ttc" id="agroup__hardware__gpio_html_ga30a6733240f3d2e25e6b579b6c3902da"><div class="ttname"><a href="group__hardware__gpio.html#ga30a6733240f3d2e25e6b579b6c3902da">gpio_pull_up</a></div><div class="ttdeci">static void gpio_pull_up(uint gpio)</div><div class="ttdoc">Set specified GPIO to be pulled up.</div><div class="ttdef"><b>Definition:</b> gpio.h:299</div></div>
<div class="ttc" id="agroup__hardware__gpio_html_ggaf91b38a4d4e96c343bd16927c34936e0af5897687741f0ee34c88fd9823f1450a"><div class="ttname"><a href="group__hardware__gpio.html#ggaf91b38a4d4e96c343bd16927c34936e0af5897687741f0ee34c88fd9823f1450a">GPIO_FUNC_I2C</a></div><div class="ttdeci">@ GPIO_FUNC_I2C</div><div class="ttdoc">Select I2C as GPIO pin function.</div><div class="ttdef"><b>Definition:</b> io_bank0.h:34</div></div>
<div class="ttc" id="agroup__hardware__i2c_html_gaba4ea440285edec58eba507308c568c6"><div class="ttname"><a href="group__hardware__i2c.html#gaba4ea440285edec58eba507308c568c6">i2c_read_blocking</a></div><div class="ttdeci">int i2c_read_blocking(i2c_inst_t *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop)</div><div class="ttdoc">Attempt to read specified number of bytes from address, blocking.</div><div class="ttdef"><b>Definition:</b> i2c.c:338</div></div>
<div class="ttc" id="agroup__hardware__i2c_html_gad31793849a130033e94fa5b8e98a30a8"><div class="ttname"><a href="group__hardware__i2c.html#gad31793849a130033e94fa5b8e98a30a8">i2c_init</a></div><div class="ttdeci">uint i2c_init(i2c_inst_t *i2c, uint baudrate)</div><div class="ttdoc">Initialise the I2C HW block.</div><div class="ttdef"><b>Definition:</b> i2c.c:32</div></div>
<div class="ttc" id="agroup__pico__base_html_ggaddcb20bc9a61ceff479aa87369a862aaa3881c25df2261efbc82252df515240d0"><div class="ttname"><a href="group__pico__base.html#ggaddcb20bc9a61ceff479aa87369a862aaa3881c25df2261efbc82252df515240d0">PICO_ERROR_GENERIC</a></div><div class="ttdeci">@ PICO_ERROR_GENERIC</div><div class="ttdoc">An unspecified error occurred.</div><div class="ttdef"><b>Definition:</b> error.h:25</div></div>
<div class="ttc" id="agroup__pico__binary__info_html_ga758f119659f2491c89e8e2955d647e9a"><div class="ttname"><a href="group__pico__binary__info.html#ga758f119659f2491c89e8e2955d647e9a">bi_decl</a></div><div class="ttdeci">#define bi_decl(_decl)</div><div class="ttdoc">Declare some binary information that will be included if the contain source file/line is compiled int...</div><div class="ttdef"><b>Definition:</b> code.h:35</div></div>
<div class="ttc" id="agroup__pico__stdio_html_ga0e604311fb226dae91ff4eb17a19d67a"><div class="ttname"><a href="group__pico__stdio.html#ga0e604311fb226dae91ff4eb17a19d67a">stdio_init_all</a></div><div class="ttdeci">bool stdio_init_all(void)</div><div class="ttdoc">Initialize all of the present standard stdio types that are linked into the binary.</div><div class="ttdef"><b>Definition:</b> stdio.c:200</div></div>
<div class="ttc" id="arp2__common_2hardware__i2c_2include_2hardware_2i2c_8h_html"><div class="ttname"><a href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html">i2c.h</a></div></div>
<div class="ttc" id="astdio_8h_html"><div class="ttname"><a href="stdio_8h.html">stdio.h</a></div></div>
<div class="ttc" id="astdlib_8h_html"><div class="ttname"><a href="stdlib_8h.html">stdlib.h</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6e96753676145c21b2165f6fde8e0f2a" name="ga6e96753676145c21b2165f6fde8e0f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e96753676145c21b2165f6fde8e0f2a">&#9670;&nbsp;</a></span>I2C_DREQ_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_DREQ_NUM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i2c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_tx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="group__hardware__dma.html#ga8def0ea481095c94f3a0dd0b4fed999e">dreq_num_t</a> used for pacing DMA transfers to or from this I2C instance. If is_tx is true, then it is for transfers to the I2C instance else for transfers from the I2C instance. </p>
<p >Note this macro is intended to resolve at compile time, and does no parameter checking </p>

</div>
</div>
<a id="gaaa18845e47b403a6a54008a776f56b46" name="gaaa18845e47b403a6a54008a776f56b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa18845e47b403a6a54008a776f56b46">&#9670;&nbsp;</a></span>I2C_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">num</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the I2C instance with the given I2C number. </p>
<p >Note this macro is intended to resolve at compile time, and does no parameter checking </p>

</div>
</div>
<a id="ga15780f5c76a6e85e6a9d91dc6ca754bc" name="ga15780f5c76a6e85e6a9d91dc6ca754bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15780f5c76a6e85e6a9d91dc6ca754bc">&#9670;&nbsp;</a></span>I2C_NUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_NUM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i2c</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the I2C number for a I2C instance. </p>
<p >Note this macro is intended to resolve at compile time, and does no parameter checking </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2e2ac8f345157b0095fc463ac3e584ba" name="ga2e2ac8f345157b0095fc463ac3e584ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e2ac8f345157b0095fc463ac3e584ba">&#9670;&nbsp;</a></span>i2c_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the I2C HW block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a></td></tr>
  </table>
  </dd>
</dl>
<p>Disable the I2C again if it is no longer used. Must be reinitialised before being used again. </p>

</div>
</div>
<a id="gacce469d1b8f8dc9548d1932c5838d9d9" name="gacce469d1b8f8dc9548d1932c5838d9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacce469d1b8f8dc9548d1932c5838d9d9">&#9670;&nbsp;</a></span>i2c_get_dreq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint i2c_get_dreq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the DREQ to use for pacing transfers to/from a particular I2C instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">is_tx</td><td>true for sending data to the I2C instance, false for receiving data from the I2C instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb868326e8b0bef077a98e1302b0ff9a" name="gafb868326e8b0bef077a98e1302b0ff9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb868326e8b0bef077a98e1302b0ff9a">&#9670;&nbsp;</a></span>i2c_get_hw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi2c__hw__t.html">i2c_hw_t</a> * i2c_get_hw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return pointer to structure containing i2c hardware registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>I2C instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <a class="el" href="structi2c__hw__t.html">i2c_hw_t</a> </dd></dl>

</div>
</div>
<a id="gaae747755a45e2fbf96d60bfbc7837f5d" name="gaae747755a45e2fbf96d60bfbc7837f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae747755a45e2fbf96d60bfbc7837f5d">&#9670;&nbsp;</a></span>i2c_get_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint i2c_get_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert I2C instance to hardware instance number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>I2C instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of I2C, 0 or 1. </dd></dl>

</div>
</div>
<a id="ga2a132ff74d7b816a6238037fa0e0c2c4" name="ga2a132ff74d7b816a6238037fa0e0c2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a132ff74d7b816a6238037fa0e0c2c4">&#9670;&nbsp;</a></span>i2c_get_instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structi2c__inst.html">i2c_inst_t</a> * i2c_get_instance </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert I2C hardware instance number to I2C instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Number of I2C, 0 or 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C hardware instance </dd></dl>

</div>
</div>
<a id="ga5df361f77f110bbc2b63baa999507bde" name="ga5df361f77f110bbc2b63baa999507bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5df361f77f110bbc2b63baa999507bde">&#9670;&nbsp;</a></span>i2c_get_read_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t i2c_get_read_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine number of bytes received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no data available, if return is nonzero at least that many bytes can be read without blocking. </dd></dl>

</div>
</div>
<a id="ga93f40022189e591521dd0ae5e29708ff" name="ga93f40022189e591521dd0ae5e29708ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93f40022189e591521dd0ae5e29708ff">&#9670;&nbsp;</a></span>i2c_get_write_available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t i2c_get_write_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine non-blocking write space available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no space is available in the I2C to write more data. If return is nonzero, at least that many bytes can be written without blocking. </dd></dl>

</div>
</div>
<a id="gad31793849a130033e94fa5b8e98a30a8" name="gad31793849a130033e94fa5b8e98a30a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31793849a130033e94fa5b8e98a30a8">&#9670;&nbsp;</a></span>i2c_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint i2c_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the I2C HW block. </p>
<p >Put the I2C hardware into a known state, and enable it. Must be called before other functions. By default, the I2C is configured to operate as a master.</p>
<p >The I2C bus frequency is set as close as possible to requested, and the actual rate set is returned</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">baudrate</td><td>Baudrate in Hz (e.g. 100kHz is 100000) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual set baudrate </dd></dl>

</div>
</div>
<a id="gaba4ea440285edec58eba507308c568c6" name="gaba4ea440285edec58eba507308c568c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba4ea440285edec58eba507308c568c6">&#9670;&nbsp;</a></span>i2c_read_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nostop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read specified number of bytes from address, blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to read from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to buffer to receive data </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to receive </td></tr>
    <tr><td class="paramname">nostop</td><td>If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged or no device present. </dd></dl>

</div>
</div>
<a id="ga186c30fab0a661586493c8d51a493850" name="ga186c30fab0a661586493c8d51a493850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga186c30fab0a661586493c8d51a493850">&#9670;&nbsp;</a></span>i2c_read_blocking_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_blocking_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nostop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read specified number of bytes from address, blocking until the specified absolute time is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to read from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to buffer to receive data </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to receive </td></tr>
    <tr><td class="paramname">nostop</td><td>If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start. </td></tr>
    <tr><td class="paramname">until</td><td>The absolute time that the block will wait until the entire transaction is complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged, no device present, or PICO_ERROR_TIMEOUT if a timeout occurred. </dd></dl>

</div>
</div>
<a id="gafb20f515799c0a68ed597eed1ad9828a" name="gafb20f515799c0a68ed597eed1ad9828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb20f515799c0a68ed597eed1ad9828a">&#9670;&nbsp;</a></span>i2c_read_burst_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_read_burst_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to read specified number of bytes from address, blocking in burst mode. </p>
<p >This version of the function will not issue a stop and will not restart on the next read. This allows you to read consecutive bytes of data without having to resend a stop bit and (for example) without having to send address byte(s) repeatedly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to read from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to buffer to receive data </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged or no device present. </dd></dl>

</div>
</div>
<a id="gab37f59a13576235e8bed4fffc4bc4361" name="gab37f59a13576235e8bed4fffc4bc4361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37f59a13576235e8bed4fffc4bc4361">&#9670;&nbsp;</a></span>i2c_read_byte_raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t i2c_read_byte_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop a byte from I2C Rx FIFO. </p>
<p >This function is non-blocking and assumes the Rx FIFO isn't empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>I2C instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Byte value. </dd></dl>

</div>
</div>
<a id="gacb6879852dedc00403f8c345e6d64611" name="gacb6879852dedc00403f8c345e6d64611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb6879852dedc00403f8c345e6d64611">&#9670;&nbsp;</a></span>i2c_read_raw_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_read_raw_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read direct from RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">dst</td><td>Buffer to accept data </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<p>Reads directly from the I2C RX FIFO which is mainly useful for slave-mode operation. </p>

</div>
</div>
<a id="ga9662f16f2e0def852f8fc051e695528d" name="ga9662f16f2e0def852f8fc051e695528d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9662f16f2e0def852f8fc051e695528d">&#9670;&nbsp;</a></span>i2c_read_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int i2c_read_timeout_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nostop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to read specified number of bytes from address, with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to read from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to buffer to receive data </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to receive </td></tr>
    <tr><td class="paramname">nostop</td><td>If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start. </td></tr>
    <tr><td class="paramname">timeout_us</td><td>The time that the function will wait for the entire transaction to complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged, no device present, or PICO_ERROR_TIMEOUT if a timeout occurred. </dd></dl>

</div>
</div>
<a id="ga615525cad9398b3ec37e8208523c73b4" name="ga615525cad9398b3ec37e8208523c73b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga615525cad9398b3ec37e8208523c73b4">&#9670;&nbsp;</a></span>i2c_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint i2c_set_baudrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C baudrate. </p>
<p >Set I2C bus frequency as close as possible to requested, and return actual rate set. Baudrate may not be as exactly requested due to clocking limitations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">baudrate</td><td>Baudrate in Hz (e.g. 100kHz is 100000) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual set baudrate </dd></dl>

</div>
</div>
<a id="ga42571b2db5d1ed0dc083385c230dc9e8" name="ga42571b2db5d1ed0dc083385c230dc9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42571b2db5d1ed0dc083385c230dc9e8">&#9670;&nbsp;</a></span>i2c_set_slave_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_set_slave_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C port to slave mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">slave</td><td>true to use slave mode, false to use master mode </td></tr>
    <tr><td class="paramname">addr</td><td>If <code>slave</code> is true, set the slave address to this value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5149e9af84926fa19db6677691ab2900" name="ga5149e9af84926fa19db6677691ab2900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5149e9af84926fa19db6677691ab2900">&#9670;&nbsp;</a></span>i2c_write_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nostop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to write specified number of bytes to address, blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to write to </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to data to send </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to send </td></tr>
    <tr><td class="paramname">nostop</td><td>If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written, or PICO_ERROR_GENERIC if address not acknowledged, no device present. </dd></dl>

</div>
</div>
<a id="gafbad5cc392c9c22618ff9fe3b0f20ea5" name="gafbad5cc392c9c22618ff9fe3b0f20ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbad5cc392c9c22618ff9fe3b0f20ea5">&#9670;&nbsp;</a></span>i2c_write_blocking_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_blocking_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nostop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to write specified number of bytes to address, blocking until the specified absolute time is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to write to </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to data to send </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to send </td></tr>
    <tr><td class="paramname">nostop</td><td>If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start. </td></tr>
    <tr><td class="paramname">until</td><td>The absolute time that the block will wait until the entire transaction is complete. Note, an individual timeout of this value divided by the length of data is applied for each byte transfer, so if the first or subsequent bytes fails to transfer within that sub timeout, the function will return with an error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written, or PICO_ERROR_GENERIC if address not acknowledged, no device present, or PICO_ERROR_TIMEOUT if a timeout occurred. </dd></dl>

</div>
</div>
<a id="ga550d01d4619f702db34355b9e570b1b1" name="ga550d01d4619f702db34355b9e570b1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550d01d4619f702db34355b9e570b1b1">&#9670;&nbsp;</a></span>i2c_write_burst_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int i2c_write_burst_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to write specified number of bytes to address, blocking in burst mode. </p>
<p >This version of the function will not issue a stop and will not restart on the next write. This allows you to write consecutive bytes of data without having to resend a stop bit and (for example) without having to send address byte(s) repeatedly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to read from </td></tr>
    <tr><td class="paramname">dst</td><td>Pointer to buffer to receive data </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to receive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes read, or PICO_ERROR_GENERIC if address not acknowledged or no device present. </dd></dl>

</div>
</div>
<a id="ga966547dafbfd2bcb2016c132f26767f8" name="ga966547dafbfd2bcb2016c132f26767f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga966547dafbfd2bcb2016c132f26767f8">&#9670;&nbsp;</a></span>i2c_write_byte_raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_write_byte_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a byte into I2C Tx FIFO. </p>
<p >This function is non-blocking and assumes the Tx FIFO isn't full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>I2C instance. </td></tr>
    <tr><td class="paramname">value</td><td>Byte value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf33250d48e1ad099b1ade910fa97e38d" name="gaf33250d48e1ad099b1ade910fa97e38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf33250d48e1ad099b1ade910fa97e38d">&#9670;&nbsp;</a></span>i2c_write_raw_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_write_raw_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write direct to TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">src</td><td>Data to send </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send</td></tr>
  </table>
  </dd>
</dl>
<p>Writes directly to the I2C TX FIFO which is mainly useful for slave-mode operation. </p>

</div>
</div>
<a id="ga0abb49ca0282530c2655f188b72eb653" name="ga0abb49ca0282530c2655f188b72eb653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abb49ca0282530c2655f188b72eb653">&#9670;&nbsp;</a></span>i2c_write_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int i2c_write_timeout_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nostop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>timeout_us</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to write specified number of bytes to address, with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>Either <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a46204d38a512926541fd8bac2b62c720">i2c0</a> or <a class="el" href="rp2__common_2hardware__i2c_2include_2hardware_2i2c_8h.html#a87659b485d9e76dfc3bcef208ac4b573">i2c1</a> </td></tr>
    <tr><td class="paramname">addr</td><td>7-bit address of device to write to </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to data to send </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes to send </td></tr>
    <tr><td class="paramname">nostop</td><td>If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start. </td></tr>
    <tr><td class="paramname">timeout_us</td><td>The time that the function will wait for the entire transaction to complete. Note, an individual timeout of this value divided by the length of data is applied for each byte transfer, so if the first or subsequent bytes fails to transfer within that sub timeout, the function will return with an error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes written, or PICO_ERROR_GENERIC if address not acknowledged, no device present, or PICO_ERROR_TIMEOUT if a timeout occurred. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga56c7844696c095a3ad088100df011fd2" name="ga56c7844696c095a3ad088100df011fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c7844696c095a3ad088100df011fd2">&#9670;&nbsp;</a></span>i2c0_inst</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structi2c__inst.html">i2c_inst_t</a> i2c0_inst</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The I2C identifiers for use in I2C functions.</p>
<p >e.g. i2c_init(i2c0, 48000) </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>