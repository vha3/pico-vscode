<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: lockout</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__multicore__lockout.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lockout<div class="ingroups"><a class="el" href="group__high__level.html">High Level APIs</a> &raquo; <a class="el" href="group__pico__multicore.html">pico_multicore</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Functions to enable one core to force the other core to pause execution in a known state.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4e969086bda6851bc8ce8199113fd595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init</a> (void)</td></tr>
<tr class="memdesc:ga4e969086bda6851bc8ce8199113fd595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the current core such that it can be a "victim" of lockout (i.e. forced to pause in a known state by the other core)  <a href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">More...</a><br /></td></tr>
<tr class="separator:ga4e969086bda6851bc8ce8199113fd595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3669ce9202da1860fcbbb11094778dd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__multicore__lockout.html#ga3669ce9202da1860fcbbb11094778dd5">multicore_lockout_victim_is_initialized</a> (uint core_num)</td></tr>
<tr class="memdesc:ga3669ce9202da1860fcbbb11094778dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init()</a> has been called on the specified core.  <a href="group__multicore__lockout.html#ga3669ce9202da1860fcbbb11094778dd5">More...</a><br /></td></tr>
<tr class="separator:ga3669ce9202da1860fcbbb11094778dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3f4df6b0e4140b0f40899a02c238d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__multicore__lockout.html#ga9a3f4df6b0e4140b0f40899a02c238d8">multicore_lockout_start_blocking</a> (void)</td></tr>
<tr class="memdesc:ga9a3f4df6b0e4140b0f40899a02c238d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the other core to pause in a known state and wait for it to do so.  <a href="group__multicore__lockout.html#ga9a3f4df6b0e4140b0f40899a02c238d8">More...</a><br /></td></tr>
<tr class="separator:ga9a3f4df6b0e4140b0f40899a02c238d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf40bf0b8b3a704f3178e38977d292be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__multicore__lockout.html#gaaf40bf0b8b3a704f3178e38977d292be">multicore_lockout_start_timeout_us</a> (uint64_t timeout_us)</td></tr>
<tr class="memdesc:gaaf40bf0b8b3a704f3178e38977d292be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the other core to pause in a known state and wait up to a time limit for it to do so.  <a href="group__multicore__lockout.html#gaaf40bf0b8b3a704f3178e38977d292be">More...</a><br /></td></tr>
<tr class="separator:gaaf40bf0b8b3a704f3178e38977d292be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b7b6dc6f81ca9524467f5024681167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__multicore__lockout.html#gab1b7b6dc6f81ca9524467f5024681167">multicore_lockout_end_blocking</a> (void)</td></tr>
<tr class="memdesc:gab1b7b6dc6f81ca9524467f5024681167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the other core from a locked out state amd wait for it to acknowledge.  <a href="group__multicore__lockout.html#gab1b7b6dc6f81ca9524467f5024681167">More...</a><br /></td></tr>
<tr class="separator:gab1b7b6dc6f81ca9524467f5024681167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad61a822f1b135db1be62c19754694fe2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__multicore__lockout.html#gad61a822f1b135db1be62c19754694fe2">multicore_lockout_end_timeout_us</a> (uint64_t timeout_us)</td></tr>
<tr class="memdesc:gad61a822f1b135db1be62c19754694fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the other core from a locked out state amd wait up to a time limit for it to acknowledge.  <a href="group__multicore__lockout.html#gad61a822f1b135db1be62c19754694fe2">More...</a><br /></td></tr>
<tr class="separator:gad61a822f1b135db1be62c19754694fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Functions to enable one core to force the other core to pause execution in a known state. </p>
<p >Sometimes it is useful to enter a critical section on both cores at once. On a single core system a critical section can trivially be entered by disabling interrupts, however on a multi-core system that is not sufficient, and unless the other core is polling in some way, then it will need to be interrupted in order to cooperatively enter a blocked state.</p>
<p >These "lockout" functions use the inter core FIFOs to cause an interrupt on one core from the other, and manage waiting for the other core to enter the "locked out" state.</p>
<p >The usage is that the "victim" core ... i.e the core that can be "locked out" by the other core calls <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init</a> to hook the FIFO interrupt. Note that either or both cores may do this.</p>
<dl class="section note"><dt>Note</dt><dd>When "locked out" the victim core is paused (it is actually executing a tight loop with code in RAM) and has interrupts disabled. This makes the lockout functions suitable for use by code that wants to write to flash (at which point no code may be executing from flash)</dd></dl>
<p>The core which wishes to lockout the other core calls <a class="el" href="group__multicore__lockout.html#ga9a3f4df6b0e4140b0f40899a02c238d8">multicore_lockout_start_blocking</a> or <a class="el" href="group__multicore__lockout.html#gaaf40bf0b8b3a704f3178e38977d292be">multicore_lockout_start_timeout_us</a> to interrupt the other "victim" core and wait for it to be in a "locked out" state. Once the lockout is no longer needed it calls <a class="el" href="group__multicore__lockout.html#gab1b7b6dc6f81ca9524467f5024681167">multicore_lockout_end_blocking</a> or <a class="el" href="group__multicore__lockout.html#gad61a822f1b135db1be62c19754694fe2">multicore_lockout_end_timeout_us</a> to release the lockout and wait for confirmation.</p>
<dl class="section note"><dt>Note</dt><dd>Because multicore lockout uses the intercore FIFOs, the FIFOs <b>cannot</b> be used for any other purpose </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab1b7b6dc6f81ca9524467f5024681167" name="gab1b7b6dc6f81ca9524467f5024681167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b7b6dc6f81ca9524467f5024681167">&#9670;&nbsp;</a></span>multicore_lockout_end_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void multicore_lockout_end_blocking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the other core from a locked out state amd wait for it to acknowledge. </p>
<dl class="section note"><dt>Note</dt><dd>The other core must previously have been "locked out" by calling a <code>multicore_lockout_start_</code> function from this core </dd></dl>

</div>
</div>
<a id="gad61a822f1b135db1be62c19754694fe2" name="gad61a822f1b135db1be62c19754694fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad61a822f1b135db1be62c19754694fe2">&#9670;&nbsp;</a></span>multicore_lockout_end_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool multicore_lockout_end_timeout_us </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the other core from a locked out state amd wait up to a time limit for it to acknowledge. </p>
<p >The other core must previously have been "locked out" by calling a <code>multicore_lockout_start_</code> function from this core</p>
<dl class="section note"><dt>Note</dt><dd>be very careful using small timeout values, as a timeout here will leave the "lockout" functionality in a bad state. It is probably preferable to use <a class="el" href="group__multicore__lockout.html#gab1b7b6dc6f81ca9524467f5024681167">multicore_lockout_end_blocking</a> anyway as if you have already waited for the victim core to enter the lockout state, then the victim core will be ready to exit the lockout state very quickly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_us</td><td>the timeout in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the other core successfully exited locked out state within the timeout, false otherwise </dd></dl>

</div>
</div>
<a id="ga9a3f4df6b0e4140b0f40899a02c238d8" name="ga9a3f4df6b0e4140b0f40899a02c238d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3f4df6b0e4140b0f40899a02c238d8">&#9670;&nbsp;</a></span>multicore_lockout_start_blocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void multicore_lockout_start_blocking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the other core to pause in a known state and wait for it to do so. </p>
<p >The other (victim) core must have previously executed <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init()</a></p>
<dl class="section note"><dt>Note</dt><dd>multicore_lockout_start_ functions are not nestable, and must be paired with a call to a corresponding <a class="el" href="group__multicore__lockout.html#gab1b7b6dc6f81ca9524467f5024681167">multicore_lockout_end_blocking</a> </dd></dl>

</div>
</div>
<a id="gaaf40bf0b8b3a704f3178e38977d292be" name="gaaf40bf0b8b3a704f3178e38977d292be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf40bf0b8b3a704f3178e38977d292be">&#9670;&nbsp;</a></span>multicore_lockout_start_timeout_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool multicore_lockout_start_timeout_us </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the other core to pause in a known state and wait up to a time limit for it to do so. </p>
<p >The other core must have previously executed <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init()</a></p>
<dl class="section note"><dt>Note</dt><dd>multicore_lockout_start_ functions are not nestable, and must be paired with a call to a corresponding <a class="el" href="group__multicore__lockout.html#gab1b7b6dc6f81ca9524467f5024681167">multicore_lockout_end_blocking</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_us</td><td>the timeout in microseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the other core entered the locked out state within the timeout, false otherwise </dd></dl>

</div>
</div>
<a id="ga4e969086bda6851bc8ce8199113fd595" name="ga4e969086bda6851bc8ce8199113fd595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e969086bda6851bc8ce8199113fd595">&#9670;&nbsp;</a></span>multicore_lockout_victim_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void multicore_lockout_victim_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the current core such that it can be a "victim" of lockout (i.e. forced to pause in a known state by the other core) </p>
<p >This code hooks the intercore FIFO IRQ, and the FIFO may not be used for any other purpose after this. </p>

</div>
</div>
<a id="ga3669ce9202da1860fcbbb11094778dd5" name="ga3669ce9202da1860fcbbb11094778dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3669ce9202da1860fcbbb11094778dd5">&#9670;&nbsp;</a></span>multicore_lockout_victim_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool multicore_lockout_victim_is_initialized </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>core_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init()</a> has been called on the specified core. </p>
<dl class="section note"><dt>Note</dt><dd>this state persists even if the core is subsequently reset; therefore you are advised to always call <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init()</a> again after resetting a core, which had previously been initialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core_num</td><td>the core number (0 or 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="group__multicore__lockout.html#ga4e969086bda6851bc8ce8199113fd595">multicore_lockout_victim_init()</a> has been called on the specified core, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>