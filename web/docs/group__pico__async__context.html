<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: pico_async_context</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__pico__async__context.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pico_async_context<div class="ingroups"><a class="el" href="group__high__level.html">High Level APIs</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An <a class="el" href="structasync__context.html">async_context</a> provides a logically single-threaded context for performing work, and responding to asynchronous events. Thus an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> instance is suitable for servicing third-party libraries that are not re-entrant.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__async__context__freertos"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__context__freertos.html">async_context_freertos</a></td></tr>
<tr class="memdesc:group__async__context__freertos"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structasync__context__freertos.html">async_context_freertos</a> provides an implementation of <a class="el" href="structasync__context.html">async_context</a> that handles asynchronous work in a separate FreeRTOS task. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__async__context__poll"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__context__poll.html">async_context_poll</a></td></tr>
<tr class="memdesc:group__async__context__poll"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structasync__context__poll.html">async_context_poll</a> provides an implementation of <a class="el" href="structasync__context.html">async_context</a> that is intended for use with a simple polling loop on one core. It is not thread safe. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__async__context__threadsafe__background"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__async__context__threadsafe__background.html">async_context_threadsafe_background</a></td></tr>
<tr class="memdesc:group__async__context__threadsafe__background"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structasync__context__threadsafe__background.html">async_context_threadsafe_background</a> provides an implementation of <a class="el" href="structasync__context.html">async_context</a> that handles asynchronous work in a low priority IRQ, and there is no need for the user to poll for work <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__work__on__timeout.html">async_work_on_timeout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "timeout" instance used by an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.  <a href="structasync__work__on__timeout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__when__pending__worker.html">async_when_pending_worker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "worker" instance used by an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.  <a href="structasync__when__pending__worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__context__type.html">async_context_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> type, providing methods common to that type.  <a href="structasync__context__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasync__context.html">async_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base structure type of all async_contexts. For details about its use, see <a class="el" href="group__pico__async__context.html">pico_async_context</a>.  <a href="structasync__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga74aa4914d98b190d2d4d84d7ff6b469e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structasync__work__on__timeout.html">async_work_on_timeout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a></td></tr>
<tr class="memdesc:ga74aa4914d98b190d2d4d84d7ff6b469e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "timeout" instance used by an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.  <a href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">More...</a><br /></td></tr>
<tr class="separator:ga74aa4914d98b190d2d4d84d7ff6b469e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975e8fa20352873b7ac76b06a497eb2b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structasync__when__pending__worker.html">async_when_pending_worker</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a></td></tr>
<tr class="memdesc:ga975e8fa20352873b7ac76b06a497eb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "worker" instance used by an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.  <a href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">More...</a><br /></td></tr>
<tr class="separator:ga975e8fa20352873b7ac76b06a497eb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd6a1433c144f4c4ea28d54176d9fc7"><td class="memItemLeft" align="right" valign="top"><a id="ga1dd6a1433c144f4c4ea28d54176d9fc7" name="ga1dd6a1433c144f4c4ea28d54176d9fc7"></a>
typedef struct <a class="el" href="structasync__context__type.html">async_context_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>async_context_type_t</b></td></tr>
<tr class="memdesc:ga1dd6a1433c144f4c4ea28d54176d9fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> type, providing methods common to that type. <br /></td></tr>
<tr class="separator:ga1dd6a1433c144f4c4ea28d54176d9fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga404d5e6a8ef79159c692dc040f2ded44"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga404d5e6a8ef79159c692dc040f2ded44">async_context_acquire_lock_blocking</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context)</td></tr>
<tr class="memdesc:ga404d5e6a8ef79159c692dc040f2ded44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock.  <a href="group__pico__async__context.html#ga404d5e6a8ef79159c692dc040f2ded44">More...</a><br /></td></tr>
<tr class="separator:ga404d5e6a8ef79159c692dc040f2ded44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9eb6dbc0442ba9cbb44a41526f3b9f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gada9eb6dbc0442ba9cbb44a41526f3b9f">async_context_release_lock</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context)</td></tr>
<tr class="memdesc:gada9eb6dbc0442ba9cbb44a41526f3b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock.  <a href="group__pico__async__context.html#gada9eb6dbc0442ba9cbb44a41526f3b9f">More...</a><br /></td></tr>
<tr class="separator:gada9eb6dbc0442ba9cbb44a41526f3b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032285b9d1a4aa325813cdbcc1f00a75"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga032285b9d1a4aa325813cdbcc1f00a75">async_context_lock_check</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context)</td></tr>
<tr class="memdesc:ga032285b9d1a4aa325813cdbcc1f00a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert if the caller does not own the lock for the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.  <a href="group__pico__async__context.html#ga032285b9d1a4aa325813cdbcc1f00a75">More...</a><br /></td></tr>
<tr class="separator:ga032285b9d1a4aa325813cdbcc1f00a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b239c998978b97eabe2aa2ad659720"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gaa4b239c998978b97eabe2aa2ad659720">async_context_execute_sync</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, uint32_t(*func)(void *param), void *param)</td></tr>
<tr class="memdesc:gaa4b239c998978b97eabe2aa2ad659720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute work synchronously on the core the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> belongs to.  <a href="group__pico__async__context.html#gaa4b239c998978b97eabe2aa2ad659720">More...</a><br /></td></tr>
<tr class="separator:gaa4b239c998978b97eabe2aa2ad659720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ea52957b11c70d908e5af6f0c715ab"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gad4ea52957b11c70d908e5af6f0c715ab">async_context_add_at_time_worker</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *worker)</td></tr>
<tr class="memdesc:gad4ea52957b11c70d908e5af6f0c715ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an "at time" worker to a context.  <a href="group__pico__async__context.html#gad4ea52957b11c70d908e5af6f0c715ab">More...</a><br /></td></tr>
<tr class="separator:gad4ea52957b11c70d908e5af6f0c715ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ef9fba4dd680a576d94c82b40b10fc3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga8ef9fba4dd680a576d94c82b40b10fc3">async_context_add_at_time_worker_at</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *worker, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> at)</td></tr>
<tr class="memdesc:ga8ef9fba4dd680a576d94c82b40b10fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an "at time" worker to a context.  <a href="group__pico__async__context.html#ga8ef9fba4dd680a576d94c82b40b10fc3">More...</a><br /></td></tr>
<tr class="separator:ga8ef9fba4dd680a576d94c82b40b10fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0792d86734a6e30b2f043b8eba42438"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gae0792d86734a6e30b2f043b8eba42438">async_context_add_at_time_worker_in_ms</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *worker, uint32_t ms)</td></tr>
<tr class="memdesc:gae0792d86734a6e30b2f043b8eba42438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an "at time" worker to a context.  <a href="group__pico__async__context.html#gae0792d86734a6e30b2f043b8eba42438">More...</a><br /></td></tr>
<tr class="separator:gae0792d86734a6e30b2f043b8eba42438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c96cc02b63e12874cae38442c7c4dd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga58c96cc02b63e12874cae38442c7c4dd">async_context_remove_at_time_worker</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *worker)</td></tr>
<tr class="memdesc:ga58c96cc02b63e12874cae38442c7c4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an "at time" worker from a context.  <a href="group__pico__async__context.html#ga58c96cc02b63e12874cae38442c7c4dd">More...</a><br /></td></tr>
<tr class="separator:ga58c96cc02b63e12874cae38442c7c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d42179771bcc8c99124c43dcc7b1350"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga9d42179771bcc8c99124c43dcc7b1350">async_context_add_when_pending_worker</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a> *worker)</td></tr>
<tr class="memdesc:ga9d42179771bcc8c99124c43dcc7b1350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a "when pending" worker to a context.  <a href="group__pico__async__context.html#ga9d42179771bcc8c99124c43dcc7b1350">More...</a><br /></td></tr>
<tr class="separator:ga9d42179771bcc8c99124c43dcc7b1350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b40c2505cd08cb542c3f1759b9e1d5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga72b40c2505cd08cb542c3f1759b9e1d5">async_context_remove_when_pending_worker</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a> *worker)</td></tr>
<tr class="memdesc:ga72b40c2505cd08cb542c3f1759b9e1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a "when pending" worker from a context.  <a href="group__pico__async__context.html#ga72b40c2505cd08cb542c3f1759b9e1d5">More...</a><br /></td></tr>
<tr class="separator:ga72b40c2505cd08cb542c3f1759b9e1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca51536a6f0344cfcbd30bd09fbaec2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga1ca51536a6f0344cfcbd30bd09fbaec2">async_context_set_work_pending</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a> *worker)</td></tr>
<tr class="memdesc:ga1ca51536a6f0344cfcbd30bd09fbaec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a "when pending" worker as having work pending.  <a href="group__pico__async__context.html#ga1ca51536a6f0344cfcbd30bd09fbaec2">More...</a><br /></td></tr>
<tr class="separator:ga1ca51536a6f0344cfcbd30bd09fbaec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb322c3f1043265624988215d3a8df9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gafdb322c3f1043265624988215d3a8df9">async_context_poll</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context)</td></tr>
<tr class="memdesc:gafdb322c3f1043265624988215d3a8df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any pending work for polling style <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.  <a href="group__pico__async__context.html#gafdb322c3f1043265624988215d3a8df9">More...</a><br /></td></tr>
<tr class="separator:gafdb322c3f1043265624988215d3a8df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f27b21dbaa264dfe59ef0f59de11db"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gad2f27b21dbaa264dfe59ef0f59de11db">async_context_wait_until</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:gad2f27b21dbaa264dfe59ef0f59de11db"><td class="mdescLeft">&#160;</td><td class="mdescRight">sleep until the specified time in an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> callback safe way  <a href="group__pico__async__context.html#gad2f27b21dbaa264dfe59ef0f59de11db">More...</a><br /></td></tr>
<tr class="separator:gad2f27b21dbaa264dfe59ef0f59de11db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6207f562c0b69c7a75cd81a783eb1055"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga6207f562c0b69c7a75cd81a783eb1055">async_context_wait_for_work_until</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, <a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a> until)</td></tr>
<tr class="memdesc:ga6207f562c0b69c7a75cd81a783eb1055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until work needs to be done or the specified time has been reached.  <a href="group__pico__async__context.html#ga6207f562c0b69c7a75cd81a783eb1055">More...</a><br /></td></tr>
<tr class="separator:ga6207f562c0b69c7a75cd81a783eb1055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7ea2fed2b274a63455773d056f6d4c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#gaae7ea2fed2b274a63455773d056f6d4c">async_context_wait_for_work_ms</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context, uint32_t ms)</td></tr>
<tr class="memdesc:gaae7ea2fed2b274a63455773d056f6d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until work needs to be done or the specified number of milliseconds have passed.  <a href="group__pico__async__context.html#gaae7ea2fed2b274a63455773d056f6d4c">More...</a><br /></td></tr>
<tr class="separator:gaae7ea2fed2b274a63455773d056f6d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga604afdcf2e76f1bf99df469edfadf7eb"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga604afdcf2e76f1bf99df469edfadf7eb">async_context_core_num</a> (const <a class="el" href="structasync__context.html">async_context_t</a> *context)</td></tr>
<tr class="memdesc:ga604afdcf2e76f1bf99df469edfadf7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the processor core this <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> belongs to.  <a href="group__pico__async__context.html#ga604afdcf2e76f1bf99df469edfadf7eb">More...</a><br /></td></tr>
<tr class="separator:ga604afdcf2e76f1bf99df469edfadf7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d09e106e04d70971d4fb6f09d5d949"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pico__async__context.html#ga66d09e106e04d70971d4fb6f09d5d949">async_context_deinit</a> (<a class="el" href="structasync__context.html">async_context_t</a> *context)</td></tr>
<tr class="memdesc:ga66d09e106e04d70971d4fb6f09d5d949"><td class="mdescLeft">&#160;</td><td class="mdescRight">End <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> processing, and free any resources.  <a href="group__pico__async__context.html#ga66d09e106e04d70971d4fb6f09d5d949">More...</a><br /></td></tr>
<tr class="separator:ga66d09e106e04d70971d4fb6f09d5d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >An <a class="el" href="structasync__context.html">async_context</a> provides a logically single-threaded context for performing work, and responding to asynchronous events. Thus an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> instance is suitable for servicing third-party libraries that are not re-entrant. </p>
<p >The "context" in <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> refers to the fact that when calling workers or timeouts within the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> various pre-conditions hold:</p>
<ol>
<li>
That there is a single logical thread of execution; i.e. that the context does not call any worker functions concurrently. </li>
<li>
That the context always calls workers from the same processor core, as most uses of <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> rely on interaction with IRQs which are themselves core-specific. </li>
</ol>
<p >THe <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> provides two mechanisms for asynchronous work:</p>
<ul>
<li><em>when_pending</em> workers, which are processed whenever they have work pending. See <a class="el" href="group__pico__async__context.html#ga9d42179771bcc8c99124c43dcc7b1350">async_context_add_when_pending_worker</a>, <a class="el" href="group__pico__async__context.html#ga72b40c2505cd08cb542c3f1759b9e1d5">async_context_remove_when_pending_worker</a>, and <a class="el" href="group__pico__async__context.html#ga1ca51536a6f0344cfcbd30bd09fbaec2">async_context_set_work_pending</a>, the latter of which can be used from an interrupt handler to signal that servicing work is required to be performed by the worker from the regular <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.</li>
<li><em>at_time</em> workers, that are executed after at a specific time.</li>
</ul>
<p >Note: "when pending" workers with work pending are executed before "at time" workers.</p>
<p >The <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> provides locking mechanisms, see <a class="el" href="group__pico__async__context.html#ga404d5e6a8ef79159c692dc040f2ded44">async_context_acquire_lock_blocking</a>, <a class="el" href="group__pico__async__context.html#gada9eb6dbc0442ba9cbb44a41526f3b9f">async_context_release_lock</a> and <a class="el" href="group__pico__async__context.html#ga032285b9d1a4aa325813cdbcc1f00a75">async_context_lock_check</a> which can be used by external code to ensure execution of external code does not happen concurrently with worker code. Locked code runs on the calling core, however <a class="el" href="group__pico__async__context.html#gaa4b239c998978b97eabe2aa2ad659720">async_context_execute_sync</a> is provided to synchronously run a function from the core of the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>.</p>
<p >The SDK ships with the following default async_contexts:</p>
<p ><a class="el" href="structasync__context__poll.html">async_context_poll</a> - this context is not thread-safe, and the user is responsible for calling <a class="el" href="group__pico__async__context.html#gafdb322c3f1043265624988215d3a8df9">async_context_poll()</a> periodically, and can use <a class="el" href="group__pico__async__context.html#ga6207f562c0b69c7a75cd81a783eb1055" title="Block until work needs to be done or the specified time has been reached.">async_context_wait_for_work_until()</a> to sleep between calls until work is needed if the user has nothing else to do.</p>
<p ><a class="el" href="structasync__context__threadsafe__background.html">async_context_threadsafe_background</a> - in order to work in the background, a low priority IRQ is used to handle callbacks. Code is usually invoked from this IRQ context, but may be invoked after any other code that uses the async context in another (non-IRQ) context on the same core. Calling <a class="el" href="group__pico__async__context.html#gafdb322c3f1043265624988215d3a8df9">async_context_poll()</a> is not required, and is a no-op. This context implements <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> locking and is thus safe to call from either core, according to the specific notes on each API.</p>
<p ><a class="el" href="structasync__context__freertos.html">async_context_freertos</a> - Work is performed from a separate "async_context" task, however once again, code may also be invoked after a direct use of the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> on the same core that the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> belongs to. Calling <a class="el" href="group__pico__async__context.html#gafdb322c3f1043265624988215d3a8df9">async_context_poll()</a> is not required, and is a no-op. This context implements <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> locking and is thus safe to call from any task, and from either core, according to the specific notes on each API.</p>
<p >Each <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> provides bespoke methods of instantiation which are provided in the corresponding headers (e.g. <a class="el" href="async__context__poll_8h_source.html">async_context_poll.h</a>, <a class="el" href="async__context__threadsafe__background_8h_source.html">async_context_threadsafe_background.h</a>, asycn_context_freertos.h). async_contexts are de-initialized by the common async_context_deint() method.</p>
<p >Multiple <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> instances can be used by a single application, and they will operate independently. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga74aa4914d98b190d2d4d84d7ff6b469e" name="ga74aa4914d98b190d2d4d84d7ff6b469e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74aa4914d98b190d2d4d84d7ff6b469e">&#9670;&nbsp;</a></span>async_at_time_worker_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structasync__work__on__timeout.html">async_work_on_timeout</a> <a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "timeout" instance used by an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>. </p>
<p >A "timeout" represents some future action that must be taken at a specific time. Its methods are called from the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> under lock at the given time</p>
<dl class="section see"><dt>See also</dt><dd>async_context_add_worker_at </dd>
<dd>
async_context_add_worker_in_ms </dd></dl>

</div>
</div>
<a id="ga975e8fa20352873b7ac76b06a497eb2b" name="ga975e8fa20352873b7ac76b06a497eb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975e8fa20352873b7ac76b06a497eb2b">&#9670;&nbsp;</a></span>async_when_pending_worker_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structasync__when__pending__worker.html">async_when_pending_worker</a> <a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "worker" instance used by an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>. </p>
<p >A "worker" represents some external entity that must do work in response to some external stimulus (usually an IRQ). Its methods are called from the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> under lock at the given time</p>
<dl class="section see"><dt>See also</dt><dd>async_context_add_worker_at </dd>
<dd>
async_context_add_worker_in_ms </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga404d5e6a8ef79159c692dc040f2ded44" name="ga404d5e6a8ef79159c692dc040f2ded44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga404d5e6a8ef79159c692dc040f2ded44">&#9670;&nbsp;</a></span>async_context_acquire_lock_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_acquire_lock_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock. </p>
<p >The owner of the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock is the logic owner of the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> and other work related to this <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> will not happen concurrently.</p>
<p >This method may be called in a nested fashion by the the lock owner.</p>
<dl class="section note"><dt>Note</dt><dd>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock is nestable by the same caller, so an internal count is maintained</dd>
<dd>
for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__pico__async__context.html#gada9eb6dbc0442ba9cbb44a41526f3b9f" title="Release the async_context lock.">async_context_release_lock</a> </dd></dl>

</div>
</div>
<a id="gad4ea52957b11c70d908e5af6f0c715ab" name="gad4ea52957b11c70d908e5af6f0c715ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ea52957b11c70d908e5af6f0c715ab">&#9670;&nbsp;</a></span>async_context_add_at_time_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool async_context_add_at_time_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an "at time" worker to a context. </p>
<p >An "at time" worker will run at or after a specific point in time, and is automatically when (just before) it runs.</p>
<p >The time to fire is specified in the next_time field of the worker.</p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "at time" worker to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the worker was added, false if the worker was already present. </dd></dl>

</div>
</div>
<a id="ga8ef9fba4dd680a576d94c82b40b10fc3" name="ga8ef9fba4dd680a576d94c82b40b10fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ef9fba4dd680a576d94c82b40b10fc3">&#9670;&nbsp;</a></span>async_context_add_at_time_worker_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool async_context_add_at_time_worker_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>at</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an "at time" worker to a context. </p>
<p >An "at time" worker will run at or after a specific point in time, and is automatically when (just before) it runs.</p>
<p >The time to fire is specified by the at parameter.</p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "at time" worker to add </td></tr>
    <tr><td class="paramname">at</td><td>the time to fire at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the worker was added, false if the worker was already present. </dd></dl>

</div>
</div>
<a id="gae0792d86734a6e30b2f043b8eba42438" name="gae0792d86734a6e30b2f043b8eba42438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0792d86734a6e30b2f043b8eba42438">&#9670;&nbsp;</a></span>async_context_add_at_time_worker_in_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool async_context_add_at_time_worker_in_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an "at time" worker to a context. </p>
<p >An "at time" worker will run at or after a specific point in time, and is automatically when (just before) it runs.</p>
<p >The time to fire is specified by a delay via the ms parameter</p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "at time" worker to add </td></tr>
    <tr><td class="paramname">ms</td><td>the number of milliseconds from now to fire after </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the worker was added, false if the worker was already present. </dd></dl>

</div>
</div>
<a id="ga9d42179771bcc8c99124c43dcc7b1350" name="ga9d42179771bcc8c99124c43dcc7b1350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d42179771bcc8c99124c43dcc7b1350">&#9670;&nbsp;</a></span>async_context_add_when_pending_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool async_context_add_when_pending_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a "when pending" worker to a context. </p>
<p >An "when pending" worker will run when it is pending (can be set via <a class="el" href="group__pico__async__context.html#ga1ca51536a6f0344cfcbd30bd09fbaec2">async_context_set_work_pending</a>), and is NOT automatically removed when it runs.</p>
<p >The time to fire is specified by a delay via the ms parameter</p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "when pending" worker to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the worker was added, false if the worker was already present. </dd></dl>

</div>
</div>
<a id="ga604afdcf2e76f1bf99df469edfadf7eb" name="ga604afdcf2e76f1bf99df469edfadf7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga604afdcf2e76f1bf99df469edfadf7eb">&#9670;&nbsp;</a></span>async_context_core_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint async_context_core_num </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the processor core this <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> belongs to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the physical core number </dd></dl>

</div>
</div>
<a id="ga66d09e106e04d70971d4fb6f09d5d949" name="ga66d09e106e04d70971d4fb6f09d5d949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66d09e106e04d70971d4fb6f09d5d949">&#9670;&nbsp;</a></span>async_context_deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>End <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> processing, and free any resources. </p>
<p >Note the user should clean up any resources associated with workers in the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> themselves.</p>
<p >Asynchronous (non-polled) async_contexts guarantee that no callback is being called once this method returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4b239c998978b97eabe2aa2ad659720" name="gaa4b239c998978b97eabe2aa2ad659720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4b239c998978b97eabe2aa2ad659720">&#9670;&nbsp;</a></span>async_context_execute_sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t async_context_execute_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t(*)(void *param)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute work synchronously on the core the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> belongs to. </p>
<p >This method is intended for code external to the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> (e.g. another thread/task) to execute a function with the same guarantees (single core, logical thread of execution) that <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> workers are called with.</p>
<dl class="section note"><dt>Note</dt><dd>you should NOT call this method while holding the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>'s lock</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">func</td><td>the function to call </td></tr>
    <tr><td class="paramname">param</td><td>the parameter to pass to the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from func </dd></dl>

</div>
</div>
<a id="ga032285b9d1a4aa325813cdbcc1f00a75" name="ga032285b9d1a4aa325813cdbcc1f00a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032285b9d1a4aa325813cdbcc1f00a75">&#9670;&nbsp;</a></span>async_context_lock_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_lock_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assert if the caller does not own the lock for the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>. </p>
<dl class="section note"><dt>Note</dt><dd>this method is thread-safe</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafdb322c3f1043265624988215d3a8df9" name="gafdb322c3f1043265624988215d3a8df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb322c3f1043265624988215d3a8df9">&#9670;&nbsp;</a></span>async_context_poll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structasync__context__poll.html">async_context_poll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any pending work for polling style <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a>. </p>
<p >For a polled <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> (e.g. <a class="el" href="group__async__context__poll.html">async_context_poll</a>) the user is responsible for calling this method periodically to perform any required work.</p>
<p >This method may immediately perform outstanding work on other context types, but is not required to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada9eb6dbc0442ba9cbb44a41526f3b9f" name="gada9eb6dbc0442ba9cbb44a41526f3b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9eb6dbc0442ba9cbb44a41526f3b9f">&#9670;&nbsp;</a></span>async_context_release_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_release_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock. </p>
<dl class="section note"><dt>Note</dt><dd>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> lock may be called in a nested fashion, so an internal count is maintained. On the outermost release, When the outermost lock is released, a check is made for work which might have been skipped while the lock was held, and any such work may be performed during this call IF the call is made from the same core that the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> belongs to.</dd>
<dd>
for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__pico__async__context.html#ga404d5e6a8ef79159c692dc040f2ded44" title="Acquire the async_context lock.">async_context_acquire_lock_blocking</a> </dd></dl>

</div>
</div>
<a id="ga58c96cc02b63e12874cae38442c7c4dd" name="ga58c96cc02b63e12874cae38442c7c4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58c96cc02b63e12874cae38442c7c4dd">&#9670;&nbsp;</a></span>async_context_remove_at_time_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool async_context_remove_at_time_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga74aa4914d98b190d2d4d84d7ff6b469e">async_at_time_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an "at time" worker from a context. </p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "at time" worker to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the worker was removed, false if the instance not present. </dd></dl>

</div>
</div>
<a id="ga72b40c2505cd08cb542c3f1759b9e1d5" name="ga72b40c2505cd08cb542c3f1759b9e1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72b40c2505cd08cb542c3f1759b9e1d5">&#9670;&nbsp;</a></span>async_context_remove_when_pending_worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool async_context_remove_when_pending_worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a "when pending" worker from a context. </p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "when pending" worker to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the worker was removed, false if the instance not present. </dd></dl>

</div>
</div>
<a id="ga1ca51536a6f0344cfcbd30bd09fbaec2" name="ga1ca51536a6f0344cfcbd30bd09fbaec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca51536a6f0344cfcbd30bd09fbaec2">&#9670;&nbsp;</a></span>async_context_set_work_pending()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_set_work_pending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__pico__async__context.html#ga975e8fa20352873b7ac76b06a497eb2b">async_when_pending_worker_t</a> *&#160;</td>
          <td class="paramname"><em>worker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark a "when pending" worker as having work pending. </p>
<p >The worker will be run from the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> at a later time.</p>
<dl class="section note"><dt>Note</dt><dd>this method may be called from any context including IRQs</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">worker</td><td>the "when pending" worker to mark as pending. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae7ea2fed2b274a63455773d056f6d4c" name="gaae7ea2fed2b274a63455773d056f6d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7ea2fed2b274a63455773d056f6d4c">&#9670;&nbsp;</a></span>async_context_wait_for_work_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_wait_for_work_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until work needs to be done or the specified number of milliseconds have passed. </p>
<dl class="section note"><dt>Note</dt><dd>this method should not be called from a worker callback</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">ms</td><td>the number of milliseconds to return after if no work is required </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6207f562c0b69c7a75cd81a783eb1055" name="ga6207f562c0b69c7a75cd81a783eb1055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6207f562c0b69c7a75cd81a783eb1055">&#9670;&nbsp;</a></span>async_context_wait_for_work_until()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_wait_for_work_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Block until work needs to be done or the specified time has been reached. </p>
<dl class="section note"><dt>Note</dt><dd>this method should not be called from a worker callback</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">until</td><td>the time to return at if no work is required </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2f27b21dbaa264dfe59ef0f59de11db" name="gad2f27b21dbaa264dfe59ef0f59de11db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f27b21dbaa264dfe59ef0f59de11db">&#9670;&nbsp;</a></span>async_context_wait_until()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void async_context_wait_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasync__context.html">async_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__timestamp.html#ga8b7f3d602cc053f05bacceeacc257ed8">absolute_time_t</a>&#160;</td>
          <td class="paramname"><em>until</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sleep until the specified time in an <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> callback safe way </p>
<dl class="section note"><dt>Note</dt><dd>for async_contexts that provide locking (not <a class="el" href="structasync__context__poll.html">async_context_poll</a>), this method is threadsafe. and may be called from within any worker method called by the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> or from any other non-IRQ context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the <a class="el" href="structasync__context.html" title="Base structure type of all async_contexts. For details about its use, see pico_async_context.">async_context</a> </td></tr>
    <tr><td class="paramname">until</td><td>the time to sleep until </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>