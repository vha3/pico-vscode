<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: repeating_timer</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__repeating__timer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">repeating_timer<div class="ingroups"><a class="el" href="group__high__level.html">High Level APIs</a> &raquo; <a class="el" href="group__pico__time.html">pico_time</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Repeating Timer functions for simple scheduling of repeated execution.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepeating__timer.html">repeating_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a repeating timer.  <a href="structrepeating__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga028fe2b7d00c1927c24131aae7c375f3"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a>) (<a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *rt)</td></tr>
<tr class="memdesc:ga028fe2b7d00c1927c24131aae7c375f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for a repeating timer.  <a href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">More...</a><br /></td></tr>
<tr class="separator:ga028fe2b7d00c1927c24131aae7c375f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga75dad2018ae1e4c154fb17cd96db9872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__repeating__timer.html#ga75dad2018ae1e4c154fb17cd96db9872">alarm_pool_add_repeating_timer_us</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, int64_t delay_us, <a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a> callback, void *user_data, <a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *out)</td></tr>
<tr class="memdesc:ga75dad2018ae1e4c154fb17cd96db9872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a repeating timer that is called repeatedly at the specified interval in microseconds.  <a href="group__repeating__timer.html#ga75dad2018ae1e4c154fb17cd96db9872">More...</a><br /></td></tr>
<tr class="separator:ga75dad2018ae1e4c154fb17cd96db9872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a6b07212ea5e106a81fc2f814a9e9e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__repeating__timer.html#gae5a6b07212ea5e106a81fc2f814a9e9e">alarm_pool_add_repeating_timer_ms</a> (<a class="el" href="structalarm__pool.html">alarm_pool_t</a> *pool, int32_t delay_ms, <a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a> callback, void *user_data, <a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *out)</td></tr>
<tr class="memdesc:gae5a6b07212ea5e106a81fc2f814a9e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a repeating timer that is called repeatedly at the specified interval in milliseconds.  <a href="group__repeating__timer.html#gae5a6b07212ea5e106a81fc2f814a9e9e">More...</a><br /></td></tr>
<tr class="separator:gae5a6b07212ea5e106a81fc2f814a9e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da55f26158144c2a9a813f69a524906"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__repeating__timer.html#ga8da55f26158144c2a9a813f69a524906">add_repeating_timer_us</a> (int64_t delay_us, <a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a> callback, void *user_data, <a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *out)</td></tr>
<tr class="memdesc:ga8da55f26158144c2a9a813f69a524906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a repeating timer that is called repeatedly at the specified interval in microseconds.  <a href="group__repeating__timer.html#ga8da55f26158144c2a9a813f69a524906">More...</a><br /></td></tr>
<tr class="separator:ga8da55f26158144c2a9a813f69a524906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02133dbe7083fcf3c7392a2cfb8243ba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__repeating__timer.html#ga02133dbe7083fcf3c7392a2cfb8243ba">add_repeating_timer_ms</a> (int32_t delay_ms, <a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a> callback, void *user_data, <a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *out)</td></tr>
<tr class="memdesc:ga02133dbe7083fcf3c7392a2cfb8243ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a repeating timer that is called repeatedly at the specified interval in milliseconds.  <a href="group__repeating__timer.html#ga02133dbe7083fcf3c7392a2cfb8243ba">More...</a><br /></td></tr>
<tr class="separator:ga02133dbe7083fcf3c7392a2cfb8243ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ad5a07a3f2300cc9d46c1c847fae6f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__repeating__timer.html#ga9ad5a07a3f2300cc9d46c1c847fae6f1">cancel_repeating_timer</a> (<a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *timer)</td></tr>
<tr class="memdesc:ga9ad5a07a3f2300cc9d46c1c847fae6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a repeating timer.  <a href="group__repeating__timer.html#ga9ad5a07a3f2300cc9d46c1c847fae6f1">More...</a><br /></td></tr>
<tr class="separator:ga9ad5a07a3f2300cc9d46c1c847fae6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Repeating Timer functions for simple scheduling of repeated execution. </p>
<dl class="section note"><dt>Note</dt><dd>The regular <em>alarm_</em> functionality can be used to make repeating alarms (by return non zero from the callback), however these methods abstract that further (at the cost of a user structure to store the repeat delay in (which the alarm framework does not have space for). </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga028fe2b7d00c1927c24131aae7c375f3" name="ga028fe2b7d00c1927c24131aae7c375f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga028fe2b7d00c1927c24131aae7c375f3">&#9670;&nbsp;</a></span>repeating_timer_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* repeating_timer_callback_t) (<a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *rt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for a repeating timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>repeating time structure containing information about the repeating time. user_data is of primary important to the user </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to continue repeating, false to stop. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga02133dbe7083fcf3c7392a2cfb8243ba" name="ga02133dbe7083fcf3c7392a2cfb8243ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02133dbe7083fcf3c7392a2cfb8243ba">&#9670;&nbsp;</a></span>add_repeating_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool add_repeating_timer_ms </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a repeating timer that is called repeatedly at the specified interval in milliseconds. </p>
<p >Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core of the default alarm pool (generally core 0). If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_ms</td><td>the repeat delay in milliseconds; if &gt;0 then this is the delay between one callback ending and the next starting; if &lt;0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1 microsecond </td></tr>
    <tr><td class="paramname">callback</td><td>the repeating timer callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to store in the <a class="el" href="structrepeating__timer.html" title="Information about a repeating timer.">repeating_timer</a> structure for use by the callback. </td></tr>
    <tr><td class="paramname">out</td><td>the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if there were no alarm slots available to create the timer, true otherwise. </dd></dl>

</div>
</div>
<a id="ga8da55f26158144c2a9a813f69a524906" name="ga8da55f26158144c2a9a813f69a524906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da55f26158144c2a9a813f69a524906">&#9670;&nbsp;</a></span>add_repeating_timer_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool add_repeating_timer_us </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delay_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a repeating timer that is called repeatedly at the specified interval in microseconds. </p>
<p >Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core of the default alarm pool (generally core 0). If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_us</td><td>the repeat delay in microseconds; if &gt;0 then this is the delay between one callback ending and the next starting; if &lt;0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1 </td></tr>
    <tr><td class="paramname">callback</td><td>the repeating timer callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to store in the <a class="el" href="structrepeating__timer.html" title="Information about a repeating timer.">repeating_timer</a> structure for use by the callback. </td></tr>
    <tr><td class="paramname">out</td><td>the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if there were no alarm slots available to create the timer, true otherwise. </dd></dl>

</div>
</div>
<a id="gae5a6b07212ea5e106a81fc2f814a9e9e" name="gae5a6b07212ea5e106a81fc2f814a9e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a6b07212ea5e106a81fc2f814a9e9e">&#9670;&nbsp;</a></span>alarm_pool_add_repeating_timer_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool alarm_pool_add_repeating_timer_ms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a repeating timer that is called repeatedly at the specified interval in milliseconds. </p>
<p >Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core the alarm pool was created on. If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the alarm pool to use for scheduling the repeating timer (this determines which timer_alarm is used, and which core calls the callback) </td></tr>
    <tr><td class="paramname">delay_ms</td><td>the repeat delay in milliseconds; if &gt;0 then this is the delay between one callback ending and the next starting; if &lt;0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1 microsecond </td></tr>
    <tr><td class="paramname">callback</td><td>the repeating timer callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to store in the <a class="el" href="structrepeating__timer.html" title="Information about a repeating timer.">repeating_timer</a> structure for use by the callback. </td></tr>
    <tr><td class="paramname">out</td><td>the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if there were no alarm slots available to create the timer, true otherwise. </dd></dl>

</div>
</div>
<a id="ga75dad2018ae1e4c154fb17cd96db9872" name="ga75dad2018ae1e4c154fb17cd96db9872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75dad2018ae1e4c154fb17cd96db9872">&#9670;&nbsp;</a></span>alarm_pool_add_repeating_timer_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alarm_pool_add_repeating_timer_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structalarm__pool.html">alarm_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>delay_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__repeating__timer.html#ga028fe2b7d00c1927c24131aae7c375f3">repeating_timer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a repeating timer that is called repeatedly at the specified interval in microseconds. </p>
<p >Generally the callback is called as soon as possible after the time specified from an IRQ handler on the core the alarm pool was created on. If the callback is in the past or happens before the alarm setup could be completed, then this method will optionally call the callback itself and then return a return code to indicate that the target time has passed.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from an IRQ handler (including alarm callbacks), and from either core.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the alarm pool to use for scheduling the repeating timer (this determines which timer_alarm is used, and which core calls the callback) </td></tr>
    <tr><td class="paramname">delay_us</td><td>the repeat delay in microseconds; if &gt;0 then this is the delay between one callback ending and the next starting; if &lt;0 then this is the negative of the time between the starts of the callbacks. The value of 0 is treated as 1 </td></tr>
    <tr><td class="paramname">callback</td><td>the repeating timer callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data to pass to store in the <a class="el" href="structrepeating__timer.html" title="Information about a repeating timer.">repeating_timer</a> structure for use by the callback. </td></tr>
    <tr><td class="paramname">out</td><td>the pointer to the user owned structure to store the repeating timer info in. BEWARE this storage location must outlive the repeating timer, so be careful of using stack space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if there were no alarm slots available to create the timer, true otherwise. </dd></dl>

</div>
</div>
<a id="ga9ad5a07a3f2300cc9d46c1c847fae6f1" name="ga9ad5a07a3f2300cc9d46c1c847fae6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ad5a07a3f2300cc9d46c1c847fae6f1">&#9670;&nbsp;</a></span>cancel_repeating_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cancel_repeating_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrepeating__timer.html">repeating_timer_t</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a repeating timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>the repeating timer to cancel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the repeating timer was cancelled, false if it didn't exist </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__alarm.html#gaa593548569c182a0d65d2e06a9c3493b" title="The identifier for an alarm.">alarm_id_t</a> for a note on reuse of IDs </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>