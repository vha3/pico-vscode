<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: hardware_watchdog</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v2.1.0
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__hardware__watchdog.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hardware_watchdog<div class="ingroups"><a class="el" href="group__hardware.html">Hardware APIs</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Hardware Watchdog Timer API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa73ccd43d6d755817e71bc3d7eb1fda6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#gaa73ccd43d6d755817e71bc3d7eb1fda6">watchdog_reboot</a> (uint32_t pc, uint32_t sp, uint32_t delay_ms)</td></tr>
<tr class="memdesc:gaa73ccd43d6d755817e71bc3d7eb1fda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define actions to perform at watchdog timeout.  <a href="group__hardware__watchdog.html#gaa73ccd43d6d755817e71bc3d7eb1fda6">More...</a><br /></td></tr>
<tr class="separator:gaa73ccd43d6d755817e71bc3d7eb1fda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab9cfb964649bc7928c72335d964e425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> (uint cycles)</td></tr>
<tr class="memdesc:gaab9cfb964649bc7928c72335d964e425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the watchdog tick.  <a href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">More...</a><br /></td></tr>
<tr class="separator:gaab9cfb964649bc7928c72335d964e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329b748919954f8b48c58049115a5c54"><td class="memItemLeft" align="right" valign="top"><a id="ga329b748919954f8b48c58049115a5c54" name="ga329b748919954f8b48c58049115a5c54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watchdog_update</b> (void)</td></tr>
<tr class="memdesc:ga329b748919954f8b48c58049115a5c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reload the watchdog counter with the amount of time set in watchdog_enable. <br /></td></tr>
<tr class="separator:ga329b748919954f8b48c58049115a5c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87042933bd6c335c21131991c83c161d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> (uint32_t delay_ms, bool pause_on_debug)</td></tr>
<tr class="memdesc:ga87042933bd6c335c21131991c83c161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the watchdog.  <a href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">More...</a><br /></td></tr>
<tr class="separator:ga87042933bd6c335c21131991c83c161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad627aed933db1187ad21853494dbe18d"><td class="memItemLeft" align="right" valign="top"><a id="gad627aed933db1187ad21853494dbe18d" name="gad627aed933db1187ad21853494dbe18d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watchdog_disable</b> (void)</td></tr>
<tr class="memdesc:gad627aed933db1187ad21853494dbe18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the watchdog. <br /></td></tr>
<tr class="separator:gad627aed933db1187ad21853494dbe18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65f5d24169045b8c7dc709e572535d94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a> (void)</td></tr>
<tr class="memdesc:ga65f5d24169045b8c7dc709e572535d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did the watchdog cause the last reboot?  <a href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">More...</a><br /></td></tr>
<tr class="separator:ga65f5d24169045b8c7dc709e572535d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455aa48ca6f11298e184d2ae0e81a085"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">watchdog_enable_caused_reboot</a> (void)</td></tr>
<tr class="memdesc:ga455aa48ca6f11298e184d2ae0e81a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did watchdog_enable cause the last reboot?  <a href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">More...</a><br /></td></tr>
<tr class="separator:ga455aa48ca6f11298e184d2ae0e81a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga536c4f5fbb5a967852b4fc8c4d2020bb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__watchdog.html#ga536c4f5fbb5a967852b4fc8c4d2020bb">watchdog_get_time_remaining_ms</a> (void)</td></tr>
<tr class="memdesc:ga536c4f5fbb5a967852b4fc8c4d2020bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of microseconds before the watchdog will reboot the chip.  <a href="group__hardware__watchdog.html#ga536c4f5fbb5a967852b4fc8c4d2020bb">More...</a><br /></td></tr>
<tr class="separator:ga536c4f5fbb5a967852b4fc8c4d2020bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Hardware Watchdog Timer API. </p>
<p >Supporting functions for the Pico hardware watchdog timer.</p>
<p >The RP-series microcontrollers have a built in HW watchdog Timer. This is a countdown timer that can restart parts of the chip if it reaches zero. For example, this can be used to restart the processor if the software running on it gets stuck in an infinite loop or similar. The programmer has to periodically write a value to the watchdog to stop it reaching zero.</p>
<h2><a class="anchor" id="watchdog_example"></a>
Example</h2>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="stdlib_8h.html">pico/stdlib.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rp2__common_2hardware__watchdog_2include_2hardware_2watchdog_8h.html">hardware/watchdog.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code hl_function" href="group__pico__stdio.html#ga0e604311fb226dae91ff4eb17a19d67a">stdio_init_all</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a>()) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Rebooted by Watchdog!\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Clean boot\n&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Enable the watchdog, requiring the watchdog to be updated every 100ms or the chip will reboot</span></div>
<div class="line">    <span class="comment">// second arg is pause on debug which means the watchdog will pause when stepping through code</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a>(100, 1);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (uint i = 0; i &lt; 5; i++) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Updating watchdog %d\n&quot;</span>, i);</div>
<div class="line">        <a class="code hl_function" href="group__hardware__watchdog.html#ga329b748919954f8b48c58049115a5c54">watchdog_update</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait in an infinite loop and don&#39;t update the watchdog so it reboots us</span></div>
<div class="line">    printf(<span class="stringliteral">&quot;Waiting to be rebooted by watchdog\n&quot;</span>);</div>
<div class="line">    <span class="keywordflow">while</span>(1);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__hardware__watchdog_html_ga329b748919954f8b48c58049115a5c54"><div class="ttname"><a href="group__hardware__watchdog.html#ga329b748919954f8b48c58049115a5c54">watchdog_update</a></div><div class="ttdeci">void watchdog_update(void)</div><div class="ttdoc">Reload the watchdog counter with the amount of time set in watchdog_enable.</div><div class="ttdef"><b>Definition:</b> watchdog.c:26</div></div>
<div class="ttc" id="agroup__hardware__watchdog_html_ga65f5d24169045b8c7dc709e572535d94"><div class="ttname"><a href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a></div><div class="ttdeci">bool watchdog_caused_reboot(void)</div><div class="ttdoc">Did the watchdog cause the last reboot?</div><div class="ttdef"><b>Definition:</b> watchdog.c:114</div></div>
<div class="ttc" id="agroup__hardware__watchdog_html_ga87042933bd6c335c21131991c83c161d"><div class="ttname"><a href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a></div><div class="ttdeci">void watchdog_enable(uint32_t delay_ms, bool pause_on_debug)</div><div class="ttdoc">Enable the watchdog.</div><div class="ttdef"><b>Definition:</b> watchdog.c:79</div></div>
<div class="ttc" id="agroup__pico__stdio_html_ga0e604311fb226dae91ff4eb17a19d67a"><div class="ttname"><a href="group__pico__stdio.html#ga0e604311fb226dae91ff4eb17a19d67a">stdio_init_all</a></div><div class="ttdeci">bool stdio_init_all(void)</div><div class="ttdoc">Initialize all of the present standard stdio types that are linked into the binary.</div><div class="ttdef"><b>Definition:</b> stdio.c:200</div></div>
<div class="ttc" id="arp2__common_2hardware__watchdog_2include_2hardware_2watchdog_8h_html"><div class="ttname"><a href="rp2__common_2hardware__watchdog_2include_2hardware_2watchdog_8h.html">watchdog.h</a></div></div>
<div class="ttc" id="astdio_8h_html"><div class="ttname"><a href="stdio_8h.html">stdio.h</a></div></div>
<div class="ttc" id="astdlib_8h_html"><div class="ttname"><a href="stdlib_8h.html">stdlib.h</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga65f5d24169045b8c7dc709e572535d94" name="ga65f5d24169045b8c7dc709e572535d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65f5d24169045b8c7dc709e572535d94">&#9670;&nbsp;</a></span>watchdog_caused_reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool watchdog_caused_reboot </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did the watchdog cause the last reboot? </p>
<dl class="section return"><dt>Returns</dt><dd>true If the watchdog timer or a watchdog force caused the last reboot </dd>
<dd>
false If there has been no watchdog reboot since the last power on reset. A power on reset is typically caused by a power cycle or the run pin (reset button) being toggled. </dd></dl>

</div>
</div>
<a id="ga87042933bd6c335c21131991c83c161d" name="ga87042933bd6c335c21131991c83c161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87042933bd6c335c21131991c83c161d">&#9670;&nbsp;</a></span>watchdog_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watchdog_enable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pause_on_debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the watchdog. </p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> value does not give a 1MHz clock to the watchdog system, then the <code>delay_ms</code> parameter will not be in milliseconds. See the datasheet for more details.</dd></dl>
<p>By default the SDK assumes a 12MHz XOSC and sets the <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> appropriately.</p>
<p >This method sets a marker in the watchdog scratch register 4 that is checked by <a class="el" href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">watchdog_enable_caused_reboot</a>. If the device is subsequently reset via a call to watchdog_reboot (including for example by dragging a UF2 onto the RPI-RP2), then this value will be cleared, and so <a class="el" href="group__hardware__watchdog.html#ga455aa48ca6f11298e184d2ae0e81a085">watchdog_enable_caused_reboot</a> will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_ms</td><td>Number of milliseconds before watchdog will reboot without watchdog_update being called. Maximum of 8388, which is approximately 8.3 seconds </td></tr>
    <tr><td class="paramname">pause_on_debug</td><td>If the watchdog should be paused when the debugger is stepping through code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga455aa48ca6f11298e184d2ae0e81a085" name="ga455aa48ca6f11298e184d2ae0e81a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455aa48ca6f11298e184d2ae0e81a085">&#9670;&nbsp;</a></span>watchdog_enable_caused_reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool watchdog_enable_caused_reboot </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did watchdog_enable cause the last reboot? </p>
<p >Perform additional checking along with <a class="el" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a> to determine if a watchdog timeout initiated by <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> caused the last reboot.</p>
<p >This method checks for a special value in watchdog scratch register 4 placed there by <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a>. This would not be present if a watchdog reset is initiated by <a class="el" href="group__hardware__watchdog.html#gaa73ccd43d6d755817e71bc3d7eb1fda6">watchdog_reboot</a> or by the RP-series microcontroller bootrom (e.g. dragging a UF2 onto the RPI-RP2 drive).</p>
<dl class="section return"><dt>Returns</dt><dd>true If the watchdog timer or a watchdog force caused (see <a class="el" href="group__hardware__watchdog.html#ga65f5d24169045b8c7dc709e572535d94">watchdog_caused_reboot</a>) the last reboot and the watchdog reboot happened after <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> was called </dd>
<dd>
false If there has been no watchdog reboot since the last power on reset, or the watchdog reboot was not caused by a watchdog timeout after <a class="el" href="group__hardware__watchdog.html#ga87042933bd6c335c21131991c83c161d">watchdog_enable</a> was called. A power on reset is typically caused by a power cycle or the run pin (reset button) being toggled. </dd></dl>

</div>
</div>
<a id="ga536c4f5fbb5a967852b4fc8c4d2020bb" name="ga536c4f5fbb5a967852b4fc8c4d2020bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga536c4f5fbb5a967852b4fc8c4d2020bb">&#9670;&nbsp;</a></span>watchdog_get_time_remaining_ms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t watchdog_get_time_remaining_ms </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of microseconds before the watchdog will reboot the chip. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of microseconds before the watchdog will reboot the chip. </dd></dl>

</div>
</div>
<a id="gaa73ccd43d6d755817e71bc3d7eb1fda6" name="gaa73ccd43d6d755817e71bc3d7eb1fda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa73ccd43d6d755817e71bc3d7eb1fda6">&#9670;&nbsp;</a></span>watchdog_reboot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watchdog_reboot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define actions to perform at watchdog timeout. </p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> value does not give a 1MHz clock to the watchdog system, then the <code>delay_ms</code> parameter will not be in milliseconds. See the datasheet for more details.</dd></dl>
<p>By default the SDK assumes a 12MHz XOSC and sets the <a class="el" href="group__hardware__watchdog.html#gaab9cfb964649bc7928c72335d964e425">watchdog_start_tick</a> appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pc</td><td>If Zero, a standard boot will be performed, if non-zero this is the program counter to jump to on reset. </td></tr>
    <tr><td class="paramname">sp</td><td>If <code>pc</code> is non-zero, this will be the stack pointer used. </td></tr>
    <tr><td class="paramname">delay_ms</td><td>Initial load value. Maximum value 8388, approximately 8.3s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab9cfb964649bc7928c72335d964e425" name="gaab9cfb964649bc7928c72335d964e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9cfb964649bc7928c72335d964e425">&#9670;&nbsp;</a></span>watchdog_start_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watchdog_start_tick </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>cycles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the watchdog tick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>This needs to be a divider that when applied to the XOSC input, produces a 1MHz clock. So if the XOSC is 12MHz, this will need to be 12. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>